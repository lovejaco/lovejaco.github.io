<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>syyim</title>
    <link>https://lovejaco.github.io/</link>
    <description>syyim</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 24 Sep 2020 00:00:00 +0000</lastBuildDate>
    
    <atom:link href="https://lovejaco.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[번역] macOS GUI 앱에 대한 시스템적인 PATH 환경 변수 설정</title>
      <link>https://lovejaco.github.io/posts/instructs-mac-os-gui-apps-about-path-environment-variable/</link>
      <pubDate>Thu, 24 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://lovejaco.github.io/posts/instructs-mac-os-gui-apps-about-path-environment-variable/</guid>
      <description>&lt;p&gt;원문 링크: &lt;a href=&#34;https://www.bounga.org/tips/2020/04/07/instructs-mac-os-gui-apps-about-path-environment-variable/&#34;&gt;Set system-wide PATH environment variable for Mac OS GUI apps&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;많은 사람들이 Mac OS GUI 앱에서 PATH 환경 변수를 인식하도록 지시하는 방법을 찾는데 어려움을 겪고 있습니다. 때때로 GUI 앱을 설치할 때 시스템에 설치된 바이너리를 사용하려고 하지만 어떤 이유에서인지 찾을 수 없습니다. 이것을 고쳐보겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;저는 이 특별한 문제로 인해 한동안 어려움을 겪었는데, 그 첫번째 앱은 &lt;a href=&#34;https://www.gnu.org/software/emacs/&#34;&gt;Emacs&lt;/a&gt; 였습니다. 어떤 이유에서인지 /usr/bin에 있는 것은 인식했지만 /usr/local/bin은 인식하지 못했습니다. 저는 그게 Emacs와 관련된 것이라고 생각했습니다. 그러다가 &lt;a href=&#34;https://qutebrowser.org/&#34;&gt;Qute 브라우저를&lt;/a&gt; 설치하고 Qute 내에서 검색중에 또 한번 시스템에서 사용 가능한 일부 바이너리를 인식하지 못하는 일이 발생했습니다.&lt;/p&gt;
&lt;p&gt;약간의 조사를 했지만 유용한 것을 찾지는 못했습니다. 그러다 어느 시점에 터미널에서 GUI 앱 (Emacs, Qute Browser, MacVim 등)을 시작하면 모든 것이 정상이라는 것을 알게 되었습니다. 시스템의 모든 바이너리를 찾을 수 있었습니다.&lt;/p&gt;
&lt;p&gt;응용 프로그램 폴더에서 해당 아이콘을 클릭하거나 Spotlight를 사용하여 앱을 시작할 때와 터미널을 사용하여 시작할 때의 동작이 다른 이유는 무엇일까요? 나는 호기심이 생겼습니다.&lt;/p&gt;
&lt;p&gt;이건 정말 진정한 지식을 찾아, 맥 OS 내부의 진정한 마스터에 이르는 아주 먼 길이었습니다.&lt;/p&gt;
&lt;p&gt;완전한 이해를 위한 첫 번째 단계는 GUI 앱이 어떻게 내가 쉘에서 설정한 PATH 환경 변수를 인식하고 있는지 내 스스로에게 질문을 던져보는 것이었습니다. 그건 아마도 ~.profile, ~/.bashrc, ~/.bash_profile, ~/.zsh_profile, ~/.zshrc, ~/.config/fish/config.fish 등으로 설정한 내용이죠.&lt;/p&gt;
&lt;p&gt;완전한 &lt;code&gt;PATH&lt;/code&gt;를 알고 있는 셸에서 부터 앱을 시작 해야 한다는 것은 말이 되지 않습니다.&lt;/p&gt;
&lt;p&gt;이 발견 덕분에 확신을 가지고 GUI 앱이 어디에서 경로를 얻는지 이해하기 위해 조사했고 약간 깊이 파고들어간 후에 답을 얻었습니다. 아이콘을 클릭하거나 Spotlight를 통해 시작되는 모든 단일 앱은 launchd 데몬에 의해 설정된 무언가에서 PATH를 가져옵니다.&lt;/p&gt;
&lt;p&gt;이제 GUI 앱에서 사용자 정의 한 PATH를 상속받게 하기 위해 다음과 같이 간단하게 /etc/launchd.conf를 변경하면 됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;setenv PATH /usr/local/bin:/usr/local/sbin:/usr/bin:/bin:/usr/sbin:/sbin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이제 /usr/bin 및 /usr/sbin에서만 바이너리를 검색하는 대신 GUI 앱은 다음 모든 경로에서 바이너리를 검색합니다. /usr/ local/bin/usr/local/sbin/usr/bin/bin/usr/sbin/sbin.&lt;/p&gt;
&lt;p&gt;컴퓨터를 재부팅하지 않고 변경 사항을 적용하려면 몇 가지 단계를 더 따라야 합니다.  - 저는 컴퓨터를 재부팅하는 것을 싫어합니다. 이 단계를 통해 launchd 및 spotlight가 새로운 설정을 인식하도록 합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ egrep &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;^setenv\ &amp;#34;&lt;/span&gt; /etc/launchd.conf | xargs -t -L &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; launchctl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이렇게 하면 모든 환경 관련 설정을 launchd로 전달합니다. 그런 다음 Dock 및 Spotlight 앱을 다시 시작해야합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ killall Dock
$ killall Spotlight
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이제 시작하는 모든 GUI 앱은 응용 프로그램 폴더의 아이콘을 클릭하거나 Spotlight를 사용하여 앱을 시작하여도 이 PATH 환경 변수를 상속받습니다.&lt;/p&gt;
&lt;p&gt;Enjoy!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[번역] PATH (MacOS) : Mac OS에서 PATH 환경 변수 모범 사례 </title>
      <link>https://lovejaco.github.io/posts/path-macos-best-practice-for-path-environment-variables-on-mac-os/</link>
      <pubDate>Thu, 24 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://lovejaco.github.io/posts/path-macos-best-practice-for-path-environment-variables-on-mac-os/</guid>
      <description>&lt;p&gt;원문 링크: &lt;a href=&#34;https://medium.com/@imstudio/path-macos-best-practice-for-path-environment-variables-on-mac-os-35ec4076a486&#34;&gt;PATH (MacOS) : Best practice for PATH Environment Variables On Mac OS&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Mac이 훌륭한 OS라는 것을 잘 아시겠지만, MacOS를 사용하다 보면 PATH 환경을 편집하는 방법을 알아야 할 필요가 있습니다. 다행히도 이 작업을 처리하는 것은 쉽습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1-환경-변수&#34;&gt;1. 환경 변수&lt;/h2&gt;
&lt;p&gt;환경 변수는 윈도, 맥 OS, 리눅스와 같은 운영체제(Operating System)에서 실행되는 모든 프로세스/사용자가 접근할 수 있는 전역 시스템 변수입니다. 환경 변수는 시스템 전체 값을 저장하는 데 유용합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PATH:&lt;/strong&gt; 가장 자주 사용되는 환경 변수로, 실행 가능한 프로그램을 검색하기 위한 디렉토리 목록을 저장합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OS:&lt;/strong&gt; 운영 체제.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;COMPUTENAME, USERNAME:&lt;/strong&gt; 컴퓨터와 현재 사용자 이름을 저장합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SystemRoot:&lt;/strong&gt; 시스템 루트 디렉토리.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(Windows) HOMEDRIVE, HOMEPATH:&lt;/strong&gt; 현재 사용자의 홈 디렉토리.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-macoslinux-환경-변수&#34;&gt;2. (macOS/Linux) 환경 변수&lt;/h2&gt;
&lt;p&gt;macOS/Unix의 환경 변수는 대소 문자를 구분합니다. 전역 환경 변수(모든 프로세스에서 사용 가능)의 이름은 대문자로, 단어는 밑줄 (_)로 연결됩니다. (예 : JAVA_HOME)&lt;/p&gt;
&lt;p&gt;지역 변수(현재 프로세스에서만 사용 가능)는 소문자입니다. 권장되는 방법은 &lt;code&gt;.bash_profile&lt;/code&gt; 파일을 편집하는 것입니다. 이 파일은 시스템에 로그인할 때마다 Bash가 읽고 그 안의 명령을 실행합니다. 가장 좋은 점은 이 파일은 사용자 전용이기 때문에 같은 시스템의 다른 사용자에게 영향을 주지 않는다는 것입니다.&lt;/p&gt;
&lt;h3 id=&#34;21--bash-셸에서-환경-변수-사용&#34;&gt;2.1 — Bash 셸에서 환경 변수 사용&lt;/h3&gt;
&lt;p&gt;대부분의 유닉스(Ubuntu/macOS)는 소위 Bash 셸을 사용합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;모든 환경 변수를 나열하려면 &amp;ldquo;env&amp;rdquo;(또는 &amp;ldquo;printenv&amp;rdquo;) 명령을 사용하고 &amp;ldquo;set&amp;quot;을 사용하여 모든 로컬 변수를 포함한 모든 변수를 나열할 수 있습니다.&lt;/li&gt;
&lt;li&gt;변수를 참조하려면 접두사 &amp;lsquo;$&amp;lsquo;와 함께 &lt;code&gt;$varname&lt;/code&gt;을 사용합니다 (Windows에서는 %varname% 사용).&lt;/li&gt;
&lt;li&gt;특정 변수의 값을 출력하려면 &lt;code&gt;echo $varname&lt;/code&gt; 명령을 사용하세요.&lt;/li&gt;
&lt;li&gt;환경 변수를 설정하려면 변수를 설정하고 전역 환경으로 내보내는 &lt;code&gt;export varname=value&lt;/code&gt; 명령을 사용합니다 (다른 프로세스에서 사용 가능). 값에 공백이 포함된 경우 값을 큰따옴표로 묶습니다.&lt;/li&gt;
&lt;li&gt;로컬(지역) 변수를 설정하려면 &lt;code&gt;varname=value&lt;/code&gt; (또는 &lt;code&gt;set varname=value&lt;/code&gt;) 명령을 사용합니다. 로컬 변수는 이 프로세스 내에서만 사용할 수 있습니다.&lt;/li&gt;
&lt;li&gt;로컬(지역) 변수를 해제하려면 &lt;code&gt;varname=&lt;/code&gt; 명령을 사용합니다. 즉, 빈 문자열로 설정 (또는 &lt;code&gt;unset varname&lt;/code&gt;)합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22--bash-셸에서-영속적으로-환경-변수를-설정하는-방법&#34;&gt;2.2 — Bash 셸에서 영속적으로 환경 변수를 설정하는 방법&lt;/h3&gt;
&lt;p&gt;홈 디렉토리의 Bash Shell 시작 스크립트 &lt;code&gt;~/.bashrc&lt;/code&gt; (또는 &amp;ldquo;~/.bash_profile&amp;rdquo; 또는 &amp;ldquo;~/.profile&amp;rdquo;)에 &lt;code&gt;export&lt;/code&gt; 명령을 배치하거나 시스템-수준의 작업을 위해 &lt;code&gt;/etc/profile&lt;/code&gt;을 배치하여 환경 변수를 영속적으로 설정할 수 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;점 (.) 포함된 파일이나 디렉토리는 기본적으로 숨겨져 있습니다. 숨겨진 파일을 표시하려면 &amp;ldquo;ls -a&amp;quot;또는 &amp;ldquo;ls -al&amp;quot;명령을 사용하세요. 맥 파인더에서 단축키는 (Shift + Command + .)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;예를 들어 PATH 환경 변수에 디렉토리를 추가하려면 &amp;ldquo;~/.bashrc&amp;rdquo; (또는 &amp;ldquo;~/.bash_profile&amp;rdquo; 또는 &amp;ldquo;~/.profile&amp;rdquo;) 끝에 다음 줄을 추가합니다. 여기서 ~(물결 표시는) 현재 사용자의 홈 디렉토리를 의미합니다. 모든 사용자의 경우에는 &amp;ldquo;/etc/profile”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1 단계 :&lt;/strong&gt; 터미널 창 열기
&lt;strong&gt;2 단계 :&lt;/strong&gt; 다음 명령을 입력합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;touch ~/.bash_profile; open ~/.bash_profile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이 파일을 통해 실행 중인 환경을 사용자 정의할 수 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Java의 경우) 다음 행을 추가하여 CLASSPATH 환경 변수를 설정할 수 있습니다. 예를 들면&lt;br&gt;
export CLASSPATH =. : /usr/local/tomcat/lib/servlet-api.jar&lt;br&gt;
Bash 셸은 콜론 (:)을 경로 구분자로 사용합니다. windows는 세미콜론 (;)을 사용합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;3 단계 :&lt;/strong&gt; PATH에 추가 하고 싶은 디렉토리를 경로를 추가하세요. 예를 들면 다음과 같습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;export IM_STUDIO_PATH&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$HOME&lt;span style=&#34;color:#e6db74&#34;&gt;/.imstudio/bin:&lt;/span&gt;$PATH&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;// Append a directory in front of the existing PATH
export PATH&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;/usr/local/mysql/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이 예제는 &lt;code&gt;~/.imstudio&lt;/code&gt; 경로를 PATH에 추가합니다. $PATH 부분은 기존 PATH를 추가하여 새 값으로 유지하므로 매우  중요합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4 단계 :&lt;/strong&gt; .bash_profile 파일을 저장하고 텍스트 편집을 종료합니다 (Command + Q).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“: wq! nano 편집기를 사용하는 경우”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;5 단계 :&lt;/strong&gt; .bash_profile을 강제 실행합니다. 이렇게하면 재부팅하지 않고 즉시 값을 로드합니다. 터미널 창에서 다음 명령을 실행하십시오.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;source ~/.bashrc
// or
source ~/.bash_profile
source ~/.profile
source /etc/profile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이제 Mac OS X 컴퓨터 시스템에서 PATH를 편집하는 방법을 알았습니다. 새 터미널 창을 열고 다음을 실행하여 새 경로를 확인할 수 있습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;echo $PATH
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이제 PATH에서 원하는 값을 볼 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6 단계 :&lt;/strong&gt; 마지막으로 PATH에 문제가 있고 잘못된 경로를 &amp;ldquo;다시 실행&amp;quot;하거나 &amp;ldquo;제거&amp;quot;하려는 경우 다음과 같이 생각할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;launchctl unsetenv IM_STUDIO_PATH&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-beautiful-tips&#34;&gt;3. Beautiful Tips&lt;/h2&gt;
&lt;h3 id=&#34;31---현재-환경-변수-설정을-확인합니다&#34;&gt;3.1 - 현재 환경 변수 설정을 확인합니다.&lt;/h3&gt;
&lt;p&gt;터미널에서 &amp;ldquo;printenv&amp;rdquo; 입력&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://miro.medium.com/max/1400/1*XmziTfiFd5oYuHTjGzFg1g.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;32--예제&#34;&gt;3.2- 예제&lt;/h3&gt;
&lt;p&gt;export JAVA_HOME = $ (/usr/libexec/java_home)
export JRE_HOME = $ (/usr/libexec/java_home)&lt;/p&gt;
&lt;h3 id=&#34;33--linux--macos-bash-shell에서-java_home을-설정하는-방법&#34;&gt;3.3 — Linux / macOS (Bash Shell)에서 JAVA_HOME을 설정하는 방법&lt;/h3&gt;
&lt;p&gt;먼저 터미널을 시작하고 다음을 실행하여 JAVA_HOME이 이미 설정되어 있는지 확인하십시오.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;echo $ JAVA_HOME
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;JAVA_HOME&lt;/code&gt; 은 JDK가 설치된 디렉토리로 설정됩니다. JDK가 설치된 디렉토리를 찾아야합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;/Library/Java/JavaVirtualMachines/…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“~/.bashrc” 끝에 다음 행을 추가하십시오.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;export JAVA_HOME&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;/path/to/JDK-installed-directory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;새 설정을 적용하려면 bash 셸을 새로 고쳐야합니다. 다음과 같이 &amp;ldquo;source&amp;quot;명령을 실행하십시오.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;// Bash 셸 새로 고침
source ~/.bashrc   // or &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;source ~/.login&amp;#34;&lt;/span&gt;
// 새 설정 확인
echo $JAVA_HOME
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Thank for your watching. Please feel free to feedback for me.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://hathaway.cc/2008/06/how-to-edit-your-path-environment-variables-on-mac/&#34;&gt;https://hathaway.cc/2008/06/how-to-edit-your-path-environment-variables-on-mac/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://osxdaily.com/2015/07/28/set-enviornment-variables-mac-os-x/&#34;&gt;https://osxdaily.com/2015/07/28/set-enviornment-variables-mac-os-x/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www3.ntu.edu.sg/home/ehchua/programming/howto/Environment_Variables.html&#34;&gt;https://www3.ntu.edu.sg/home/ehchua/programming/howto/Environment_Variables.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Sourcetree(osx)에서 Husky(git-commit-hook)가 동작하지 않는 이유: Can’t find “…” in PATH</title>
      <link>https://lovejaco.github.io/posts/sourcetreeosx%EC%97%90%EC%84%9C_huskygit-commit-hook%EA%B0%80_%EB%8F%99%EC%9E%91%ED%95%98%EC%A7%80_%EC%95%8A%EB%8A%94_%EC%9D%B4%EC%9C%A0/</link>
      <pubDate>Thu, 24 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://lovejaco.github.io/posts/sourcetreeosx%EC%97%90%EC%84%9C_huskygit-commit-hook%EA%B0%80_%EB%8F%99%EC%9E%91%ED%95%98%EC%A7%80_%EC%95%8A%EB%8A%94_%EC%9D%B4%EC%9C%A0/</guid>
      <description>&lt;p&gt;사실 이 현상은 Husky나 Sourcetree의 문제가 아니라 Mac GUI 앱에서 PATH 환경변수를 올바르게 인식하지 못하는 문제로, 다른 앱에서도 유사한 현상이 발생할 수 있습니다. 이 게시물에서는 이와 같은 현상이 왜 발생하며 어떻게 조치해야 하는지에 대해서 설명 합니다.&lt;/p&gt;
&lt;h2 id=&#34;husky&#34;&gt;Husky&lt;/h2&gt;
&lt;p&gt;최근 합류한 프로젝트에서는 &lt;a href=&#34;https://www.npmjs.com/package/husky&#34;&gt;Husky&lt;/a&gt;를 도입하여 git-commit-hook에서 노드 버전을 고정하거나, Lint와 같은 여러 사전 작업을 수행하고 검사합니다.&lt;/p&gt;
&lt;p&gt;저는 주로 터미널을 이용하여 Git 커맨드를 수행하지만 가끔씩 Sourcetre를 사용하기도 하는데 터미널에서 커밋을 작성하면 잘 동작하지만, Sourcetree에서는 hook이 실패하는 현상이 발생하였습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sourcetree &amp;gt; View &amp;gt; Show Command History&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;.huskyrc: line 9: nvm: command not found
env: node: No such file or directory
Can&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;t find Husky, skipping pre-commit hook
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;You can reinstall it using &amp;#39;&lt;/span&gt;npm install husky --save-dev&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;#39;&lt;/span&gt; or delete this hook
Completed successfully
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;노드 버전을 고정하기 위한 사용하는 nvm 커맨드를 찾을 수 없음&lt;/p&gt;
&lt;h3 id=&#34;husky-이슈-리포트&#34;&gt;Husky 이슈 리포트&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/typicode/husky/issues/390&#34;&gt;Husky Repo&lt;/a&gt;에 올라온 유사한 이슈에서 프로젝트 오너는 다음과 같이 설명 합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;그것은 실제로는 오류가 아니라 정보 메시지 입니다. 그러나 출력이 빨간색이므로 오류처럼 보일 수 있습니다.&lt;/p&gt;
&lt;p&gt;노드 버전 관리자(nvm)는 터미널이 시작될 때 PATH를 수정하여 동작합니다. 일반적으로 GUI 클라이언트는 nvm이 초기화를 위해 .bashrc 또는.zshrc 설정을 적용하는 source 명령을 실행하지 않기 때문에 nvm과 잘 동작하지 않습니다.&lt;/p&gt;
&lt;p&gt;따라서 이 메시지는 Husky가 노드 바이너리를 찾으려는 모드로 진입할 것이라는 것을 알려주기 위한 것입니다 (  &lt;a href=&#34;https://github.com/sindresorhus/run-node&#34;&gt;run-node&lt;/a&gt;을 사용합니다.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/typicode/husky#node-version-managers&#34;&gt;Husky 공식 문서&lt;/a&gt;에는 다음과 같이 설명 되어 있습니다.&lt;/p&gt;
&lt;h4 id=&#34;node-version-managers&#34;&gt;Node version managers&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Windows를 사용하는 경우 husky는 시스템에 전역적으로 설치된 버전을 사용합니다.&lt;/p&gt;
&lt;p&gt;macOS 및 Linux 사용자의 경우 :&lt;br&gt;
터미널에서 git 명령을 실행하는 경우 husky는 Shell의 PATH에 정의된 버전을 사용합니다. 즉, nvm 사용자 인 경우 husky는 nvm으로 설정한 노드 버전을 사용합니다.&lt;/p&gt;
&lt;p&gt;GUI 클라이언트와 함께 nvm을 사용하는 경우에는 PATH가 달라서 nvm을 로드하지 않을 수 있습니다. 이 경우 일반적으로 nvm에 의해 설치된 가장 높은 노드 버전이 선택됩니다. 또한 ~/.node_path를 확인하여 GUI에서 사용하는 버전을 확인하거나 다른 것을 사용하려는 경우 편집할 수도 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그러니까 macOS에서 GUI 클라이언트를 사용하면 일반적으로 .bashrc 또는.zshrc로 설정한 사용자 지정 환경 변수들을 인식하지 않기 때문에 Shell의 환경과 다를 수 있습니다&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;Can&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;#39;&lt;/span&gt;t find yarn in PATH: /Applications/Xcode.app/Contents/Developer/usr/libexec/git-core:/Applications/Sourcetree.app/Contents/Resources/bin:/usr/bin:/Applications/Sourcetree.app/Contents/Resources/git_local/gitflow:/Applications/Sourcetree.app/Contents/Resources/git_local/git-lfs:/usr/bin:/bin:/usr/sbin:/sbin
Skipping pre-commit hook
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;.huskyrc&lt;/code&gt;  파일을 삭제하고 테스트를 진행하면 역시나 PATH를 찾지 못하는 것을 확인할 수 있음.&lt;/p&gt;
&lt;p&gt;Husky를 사용 중이며 Sourcetree에서 nvm을 로드할 수 있도록 조치해야 한다면 가장 보편적으로 수행하는 방법은 &lt;code&gt;.huskyrc&lt;/code&gt; 에서 PATH 환경 변수를 설정해야 합니다.-  &lt;a href=&#34;https://github.com/typicode/husky/issues/390#issuecomment-545855628&#34;&gt;참고&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;그러나 사용자에 따라 PATH가 동일하지 않을 수 있습니다. 예를 들면, 설치된 방법에 따라 PATH가 다를 수 있기 때문에 자신의 환경을 고려하여 내용을 추가 해야 합니다.  -  .bashrc 또는.zshrc 설정을 참고 할 것&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;mac-gui&#34;&gt;Mac GUI&lt;/h2&gt;
&lt;p&gt;그렇다면 왜 맥 GUI 앱에서는 PATH를 올바르게 찾을 수 없는 현상이 발생할까요? 사실 이 글의 제목에서 처럼 Sourcetree에서 문제의 원인을 찾으려 했을때는 맥 환경이 그렇다는 글들만 종종 발견할 수 있었고 다음과 같은 조치를 제안 하고 있었습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;터미널에서 open 명령으로 Sourcetreee 를 실행 할 것&lt;/li&gt;
&lt;li&gt;마찬가지로 터미널에서 Sourcetree 의 CLI &lt;code&gt;stree&lt;/code&gt; 명령으로 실행할 것&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;네, 확실히 잘 동작합니다. 하지만, 매번 터미널 명령으로 Sourcetreee를 실행하는 것은 불편합니다.
편리하게 사용 할 방법이 없을까 고민을 하다보니, 왜 Mac GUI 응용프로그램에서는 내가 알고있는 PATH 환경변수와 동일하지 않을까? 궁금해졌습니다&lt;/p&gt;
&lt;p&gt;이와 관련된 아주 좋은 글을 발견하였고, 간단하게 번역을 해 두었습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://lovejaco.github.io/posts/path-macos-best-practice-for-path-environment-variables-on-mac-os/&#34;&gt;번역 - Mac OS에서 PATH 환경 변수 이해 하기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://lovejaco.github.io/posts/instructs-mac-os-gui-apps-about-path-environment-variable/&#34;&gt;번역 - Mac OS GUI 앱에 대한 시스템 수준에서 PATH 환경 변수 설정 하기&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Dock 이나 Spotlight을 통해 실행하는 Mac GUI 앱은 launchd 데몬을 통해 PATH를 상속 받습니다. 따라서 SHELL 에서 설정한 사용자 지정 PATH와 일치 하지 않습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;조치&#34;&gt;조치&lt;/h2&gt;
&lt;p&gt;만약 맥의 GUI 앱에서도 SHELL에서 설정한 PATH 환경변수를 인식하기 위해서는 다음의 조치가 필요 합니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Husky 와 같이 연동되는 모듈의 설정 파일에서 설정&lt;/li&gt;
&lt;li&gt;터미널에서 앱을 실행 하기&lt;/li&gt;
&lt;li&gt;launchd 설정을 수정하여 쉘에 적용되는 설정을 상속&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;추가&#34;&gt;추가&lt;/h3&gt;
&lt;p&gt;시스템 전역 환경변수를 추가하는 방법은 macOS 10.10 이후부터 &lt;a href=&#34;http://www.drjackyl.de/how/to/2017/08/15/Set_Global_Environment_Variables_in_macOS_10.10_and_later.html&#34;&gt;변경&lt;/a&gt;된 것으로 파악되었습니다. 개인적으로는 Sourctree 외에는 Shell의 환경변수를 적용해야 하는 앱이 아직은 없기 때문에 이 방법을 테스트 하지는 않았습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[번역] 나는 더 이상 관리자가 되고 싶지 않았습니다.</title>
      <link>https://lovejaco.github.io/posts/i-didnt-want-to-be-a-manager-anymore/</link>
      <pubDate>Sun, 07 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://lovejaco.github.io/posts/i-didnt-want-to-be-a-manager-anymore/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;2019년 3월, 블로그 피드를 통해 이 게시물을 읽은 시점에는 저 역시 글쓴이가 겪은 일들과 비슷한 일을 겪고 있었습니다. 그래서 이 글은 제가 관리자를 그만둘 결심을 부추기는 촉매가 되었습니다. 그러나 아쉽게도 저에게 해피엔딩은 없었습니다. 관리자를 그만둔 지 1년여가 지난 현재 시점에 당시 메모와 함께 그때를 회상해 보면 이 게시물은 저의 경력 성장 측면에서 분명히 좋은 영향(영감)을 주었습니다. - 글쓴이에게 감사의 말을 전합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;원문 링크: &lt;a href=&#34;https://engineering.gusto.com/i-didnt-want-to-be-a-manager-anymore-and-the-world-didnt-end/&#34;&gt;I Didn’t Want to Be a Manager Anymore—and the World Didn’t End&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;저는 2017년에 Gusto의 엔지니어링 관리자가 되었습니다. 이후 1년간 많은 것을 배웠고, 그 후에 관리자를 그만두었습니다.&lt;/p&gt;
&lt;p&gt;많은 사람들에게 있어 소프트웨어 엔지니어링 경력 개발의 성공은 관리자가 되는 것입니다. 이런 생각이 일정 부분 저를 관리자 역할을 수행하도록 이끌었습니다. 저의 경험이 다른 사람들에게 도움이 되길 바라는 마음에서 제 이야기를 공유합니다.&lt;/p&gt;
&lt;p&gt;이 게시물에 관한 내용:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;엔지니어링 관리자(engineering managemen)로 가는 나의 여정&lt;/li&gt;
&lt;li&gt;도중에 배운 교훈&lt;/li&gt;
&lt;li&gt;자신의 진로를 고민하는 독자들을 위한 핵심&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;나는 이스라엘에서 자랐고 컴퓨터 과학 석사 학위를 마친 후 샌프란시스코로 이주하여 &lt;a href=&#34;https://gusto.com/&#34;&gt;구스토&lt;/a&gt;의 Benefits Engineering 팀에 합류하여 중소기업 직원들의 건강에 도움을 주는 소프트웨어를 개발했습니다.&lt;/p&gt;
&lt;p&gt;팀은 훌륭했고, 나는 끊임없이 새로운 것을 배우며 성장했습니다.
그러나 제가 예상하지 못한 일이 벌어졌습니다.&lt;/p&gt;
&lt;h2 id=&#34;lesson-1--직무-전환에-관심이-있다면-사람들에게-이야기하세요&#34;&gt;Lesson #1 : 직무 전환에 관심이 있다면, 사람들에게 이야기하세요!&lt;/h2&gt;
&lt;p&gt;제가 직무를 수행한지 1년 정도 지났을 때, 제 매니저가 다른 엔지니어링 팀으로 이동하였습니다. 필요한 역할을 다른 팀의 인원으로 채우는 것은 빠르게 성장하는 회사의 부작용 중 하나입니다.&lt;/p&gt;
&lt;p&gt;그의 부서 이동은 나를 당황스럽게 만들었지만, 나는 그를 대신할 수 있다는 것을 깨달았습니다. 저는 팀 역학(dynamics), 혜택 영역(benefits domain) 그리고 우리의 제품과 디자인 파트너에 대해 잘 알고 있었고 목표를 달성할 수 있다고 생각했습니다. 그렇지만 저는 관리자 후보 대상자로 고려되고 있지 않았습니다.&lt;/p&gt;
&lt;p&gt;나는 많은 좌절감을 느꼈고, 짜증이 났습니다. 그러나 팀과 이야기한 후, 그제야 왜 그런 일이 일어났는지 깨달았습니다. 구스토(나 자신을 포함하여)의 누구도 제가 팀을 이끌고 싶다는 것을 알지 못했습니다. 그러니 당연하게도 그 포지션을 서둘러 충원해야 하는 시점에는, 제 이름이 부각되지 않았습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;직무 전환에 관심이 있다면, 사람들에게 그것에 관해 이야기하십시오!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;누구에게 말해야 할까요? 먼저 - 당신의 직속 관리자뿐만 아니라 그들의 관리자, 동료 및 기타 회사의 다른 리더들에게 “Y로 인해 X 역할로 전환하는 데 관심이 있습니다. 혹시 조언을 구해도 될까요?”라고 말하면서 대화를 시작할 수 있습니다.&lt;/p&gt;
&lt;p&gt;공개적으로 회사 전체에 이메일을 보내야 한다고 말하는 것은 아니지만, 이 소문이 퍼지는 것은 크게 두 가지 장점이 있습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;관리자와 동료들은 그 역할에 대한 여러분의 평가를 시작하고 목표 달성에 도움이 되는 구체적인 피드백을 제공할 수 있습니다.&lt;/li&gt;
&lt;li&gt;직무 전환에는 일정한 시간이 필요하며 이러한 기회가 발생하면 신속하게 의사 결정을 내려야 합니다. 이때 고려되는 이름은 보통 과거에 관심을 표명한 사람들입니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;당신이 직무 전환에 관심이 있다는 것을 적절한 사람들에게 알려야 합니다.&lt;/p&gt;
&lt;p&gt;이 경험 후에, 저는 사람들에게 팀을 이끄는 데 관심이 있다고 말하기 시작했습니다. 저는 이것을 즉각적으로 어려운 요구사항(“가능한 한 빨리 팀을 관리하고 싶습니다. 또는 떠나겠습니다.”) 대신 1:1 대화를 통해 그 역할의 수행을 위해 개발해야 할 기술에 대한 조언을 구했습니다. 이런 식으로 당장 성취하기 어려운 것을 요구한다는 느낌이 들지 않도록 하면서도 내가 원하는 것에 대해 쉽게 이야기 할 수 있었습니다.&lt;/p&gt;
&lt;p&gt;곧 또 다른 기회가 찾아왔습니다. 다른 팀의 리더 몇 명이 팀을 옮기고 있었기 때문에 충원이 필요했습니다. 우연히도, 나는 몇 주 전에 팀장과 연락한 적이 있었습니다. 우리는 덴버 사무실에서 비공식적인 1:1 미팅을 했습니다. (레슨 # 1에서 이야기 한 대로) 나는 목표를 세웠고, 그는 내가 팀을 이끌고 싶다는 것을 알게 되었습니다. 그래서 이 일이 발생하자, 그는 나에게 손을 내밀어 이 기회를 원하는지 물었고 나는 그렇다고 답했습니다.&lt;/p&gt;
&lt;p&gt;관리상의 의사 결정을 신속하게 내려야 한다고 얘기한 것을 기억하시나요? 이때가 그 순간들중 하나였습니다. 관리자가 팀을 떠날 때 구성원들은 불안정하며 불확실하다고 느낄 수 있습니다. 리더십은 이런 영향을 완화하기 위해 빠르게 나아가야 합니다. 이와 같은 기회는 특히 급 성장하는 회사에서 자주 발생합니다.&lt;/p&gt;
&lt;h3 id=&#34;lesson-2--자신에-대해-바로-알기&#34;&gt;Lesson #2 : 자신에 대해 바로 알기.&lt;/h3&gt;
&lt;p&gt;곧 나는 새로운 팀, 새로운 영역, 그리고 새로운 도전에 뛰어들었습니다. 배워야 할 것들이 많았기 때문에 나의 전 매니저와 같이 과거에 존경했던 롤 모델에서 영감을 찾았습니다.&lt;/p&gt;
&lt;p&gt;나는 그들과 똑같이 되고 싶었고, 이것은 다음을 의미했습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어떤 프로젝트로부터 팀의 장애물을 해제할 수 있다는 것은 다른 누구보다 코드를 잘 알고 있다는 의미입니다.&lt;/li&gt;
&lt;li&gt;우리 팀이 흥미롭게 일을 할 수 있도록 위해 힘든 일을 도맡아서 해야 합니다.&lt;/li&gt;
&lt;li&gt;더 나은 엔지니어와, 더 나은 동료가 되는 방법을 찾는 데 도움을 줄 수 있어야 합니다.&lt;/li&gt;
&lt;li&gt;제품, 디자인, 규정 준수, 지원, 영업, 기술 문서 작성자 및 기타 엔지니어링 팀과 협력하여 팀을 대신하여 외부 커뮤니케이션 담당자 역할을 합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;설상가상으로 상황이 좀 더 복잡하게 되었습니다. 나는 Benefits Engineering 영역에서 Payroll Engineering 영역으로 바뀌었고, 그것은 처음부터 시작해야 한다는 것을 의미했습니다. 나는 코드와 도메인을 이해하지 못했으며, 유관부서나 이해 관계자 심지어 내 팀에 대해서도 알지 못했습니다.&lt;/p&gt;
&lt;p&gt;처음 몇 달은 힘들었습니다. “될 때까지 하다 보면 그렇게 되겠지”라는 마음으로 가능한 많은 것을 배우려고 노력했습니다. &lt;a href=&#34;https://newspeppermint.com/2018/06/15/imposter-syndrome/&#34;&gt;가면 증후군 - 역자 주&lt;/a&gt; 으로 고통받고 있을 때 나를 지도하고 격려해 주는 관리자가 있다는 것은 굉장한 행운이었습니다.&lt;/p&gt;
&lt;p&gt;관리자가 되고 나서야 “다른 측면”이 보이기 시작했습니다. 일대일 면담을 준비하고, 하루하루 팀원들의 업무에 관여하고, 피드백을 줄 기회를 포착하고, 어떻게 하면 친절하게 피드백을 제공할 수 있을지 생각해야 했습니다. 이처럼 관리자 역할에는 많은 비하인드 작업이 필요하다는 것을 관리자가 되고 나서야 알게 되었습니다.&lt;/p&gt;
&lt;p&gt;내 롤 모델들은 어떻게 이 모든 것을 해낼 수 있었을까? 동료인 &lt;a href=&#34;https://kellysutton.com/&#34;&gt;Kelly Sutton&lt;/a&gt;은 구스토의 20여 명의 엔지니어링 관리자의 데이터를 분석하였습니다. 직접 관리하는 직원이 4명 이하인 관리자는 여전히 코드를 자주 작성하지만 5명 이상인 관리자는 코드를 전혀 작성하고 있지 않았습니다. 이 결과는 나에게 매우 충격적이었지만 한편으로 4명을 관리하면서 코드를 작성하는 것이 얼마나 어려울지 좀 더 객관적으로 바라보는 계기가 되었습니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;관리대상 직원 수&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;주당 평균 PR(Pull Request) 수&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4명 또는 그 이하&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1-3 PR&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5명 또는 그 이상&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0 PR&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;관리자가 된 지 1년쯤 되었을 때 나는 번-아웃을 느꼈습니다. 나는 세 개의 다른 역할을 수행하고 있었고 각각의 역할을 수행하는 것보다 더 많은 주의를 기울여야 했습니다.&lt;/p&gt;
&lt;h3 id=&#34;개인-기여자-역할-the-individual-contributor-hat&#34;&gt;개인 기여자 역할 (The Individual Contributor Hat)&lt;/h3&gt;
&lt;p&gt;코딩을 계속하는 것은 나에게는 매우 중요했습니다. 내 생각에 이상적인 관리자는 어떤 문제로부터 팀원이 겪는 장애물을 제거해주어야 하며, 모든 기술적인 판단에는 비판적인 시각을 적용하여, 어떤 요구사항이라도 더 효과적으로 구현할 수 있는 방법을 제시할 수 있어야 한다고 생각합니다. 코드에서 한 발짝 물러서면 내 개인적인 기술 발전이 정체될 수 있다고 생각 했습니다. - 이미 다른 두 개의 역할을 수행하는 데 많은 시간을 보냈기 때문에 기술적으로 정체됨을 느끼고 있었습니다.&lt;/p&gt;
&lt;h3 id=&#34;기술-리더-역할-the-tech-lead-hat&#34;&gt;기술 리더 역할 (The Tech Lead Hat)&lt;/h3&gt;
&lt;p&gt;구스토에는 “Technical Anchor”라고 부르는 역할은 팀의 기술 방향을 설정하고, 기술 역량을 강화하며, 프로젝트 및 &lt;a href=&#34;https://sadboxabc.blogspot.com/2019/12/capacity-planning.html&#34;&gt;용량 계획 - 역자 주&lt;/a&gt;에 기여합니다. 이러한 유형의 작업은 보다 전략적인 수준에서 영향력을 행사하고, 소프트웨어 개발에 대한 더 큰 그림을 볼 수 있는 능력을 발휘해야 하므로 리더십 관점에서 저에게 가장 매력적인 부분이었습니다.&lt;/p&gt;
&lt;h3 id=&#34;관리자-역할-the-manager-hat&#34;&gt;관리자 역할 (The Manager Hat)&lt;/h3&gt;
&lt;p&gt;우리가 &amp;lsquo;People Empower&amp;rsquo;라고 부르는 역할은 좀 더 고전적인 관리자의 역할입니다. 여기에는 1:1 코치, 피드백, 업적 평가, 승진, 채용 및 잡다한 업무를 포함합니다.&lt;/p&gt;
&lt;p&gt;결과적으로, 이 부분이 내가 가장 잘 모르는 분야이며, 가면 증후군을 느끼게 하는 원인이었습니다. 나는 정말로 이 일을 잘하고 싶었고, 예상했던 것보다 훨씬 더 많은 시간을 들였지만, 이것이 무엇을 필요로 하는지 겉으로 보기에는 분명히 드러나지 않았습니다.&lt;/p&gt;
&lt;p&gt;관리자가 아닌 경우, 수행한 관리 업무의 대부분은 자신의 관리자와의 1:1 면담 및 평가를 통해 드러납니다. 내가 관리자가 되기 전에 이런 업무들은 내 시간의 훨씬 적은 부분을 차지했지만, 지금은 4명으로 구성된 작은 팀인데도 시간이 상당히 걸립니다.&lt;/p&gt;
&lt;h3 id=&#34;the-a-ha-moment&#34;&gt;The A-Ha moment&lt;/h3&gt;
&lt;p&gt;돌이켜 보면, 어떤 날이 떠오릅니다. 그날은 많은 관리 업무들이 예정되어 있었고 출근길에 문득 이런 업무들이 더 이상 저를 두렵게 하지 않는다는 것을 깨달았습니다. 사실, 하루가 잘 풀릴 것이라고 확신했습니다.&lt;/p&gt;
&lt;p&gt;이것이 터닝포인트가 되었어야 했습니다. 관리자 역할은 나에게 더 이상 어려운 역할이 아니었습니다. 업무를 어떻게 풀어내야 할지 알고 있었고, 그리 심각한 상황이 아직 벌어지지도 않았습니다. 그럼에도 불구하고 나는 내 앞에 펼쳐질 날들이 두려웠습니다.&lt;/p&gt;
&lt;p&gt;나중에, 왜 이런 느낌이 들었는지 알아내려고 노력했습니다. 이러한 유형의 업무를 수행할 수 있다는 자신감을 얻었지만, 여전히 어떤 기대감이 들지 않는다는 것을 깨달았습니다. 필요한 업무이고, 잘하고 싶었고, ??(by well-intentioned people - 해석 불가)지만 그것을 하고 싶다는 특별한 열망을 느끼지 못했습니다.&lt;/p&gt;
&lt;p&gt;바로 이 순간이 내가 “아하” 외친 순간이었습니다. 관리 업무는 나에게 아무런 만족을 주지 못했습니다. 나는 더 이상 관리자가 되고 싶지 않다는 것을 깨달았습니다.&lt;/p&gt;
&lt;p&gt;그래서 이제 어쩌죠?&lt;/p&gt;
&lt;h2 id=&#34;lesson-3--lesson--1을-기억합니까&#34;&gt;Lesson #3 : lesson # 1을 기억합니까?!&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;직무 전환에 관심이 있다면, 사람들에게 그것에 관해 이야기하십시오!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;원점으로 돌아온 것을 느꼈습니다. 나는 나의 매니저에 대해 내 상황을 솔직히 얘기하는 것이 두려웠습니다. 그는 나에게 기회를 준 사람이었고 인내심을 가지고 지도해준 사람이었습니다.&lt;/p&gt;
&lt;p&gt;그는 뭐라고 말할까?&lt;br&gt;
나에 대한 신뢰감이 사라질까?&lt;br&gt;
이 역할을 유지하기 위해 나와 협상하려고 할까?&lt;/p&gt;
&lt;p&gt;레슨 #1을 기억하면서 어려웠지만, 시간을 낭비하지 않고 지체 없이 1:1 면담을 통해 내가 왜 이 역할을 맡고 나서 행복하지 않다고 느끼는지 이야기했습니다. 그는 제 말을 듣고 놀랍게도 변화를 위한 즉각적인 조치를 해주려 했습니다.&lt;/p&gt;
&lt;p&gt;면담 후에, 팀의 새로운 매니저 채용 공고를 냈고, 그로 인해 저는 기술 책임자와 개인 기여자로 활동할 수 있었습니다. 후임자는 약 한 달 후에 합류했습니다.&lt;/p&gt;
&lt;p&gt;이 변화는 나에게 큰 위안이 되었습니다. 그것은 내가 정말 좋아하는 역할에 집중하고 더 많은 시간을 보낼 수 있게 해주었습니다. 또한 회사의 배려 덕분에 좌천이 아닌 경력의 성장의 느낌을 받았습니다. 우리의 엔지니어링 조직은 역할의 변경을 승진이나 좌천으로 취급하지 않습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;만약 여러분이 다른 회사에 이직할 것을 고려하고 있다면, 그곳이 직무 전환을 지원하는지 여부를 고려하세요. 그리고 언젠가 여러분이 정말로 원하는 것을 나중에서야 발견할 수 있음을 명심하세요.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;경력-변경을-원한다면&#34;&gt;경력 변경을 원한다면&lt;/h2&gt;
&lt;p&gt;내 자신에게 물어볼 수 있는 몇 가지 질문:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;현재 역할에 대해 좋은 점은 무엇인가요? 만약 다른 역할을 수행하게 된다면 그런 측면들이 어떻게 변하게 될 것 같은가요?&lt;/li&gt;
&lt;li&gt;새로운 역할에 대해 기대하는 측면은 무엇입니까? 역할을 전환하지 않고도 더 많은 유형의 작업을 수행할 수 있습니까? 그렇다면 어떻게 인정받을 수 있습니까?&lt;/li&gt;
&lt;li&gt;역할에서 좋아하지 않는 측면은 무엇입니까? 왜 그런가요?&lt;/li&gt;
&lt;li&gt;새로운 역할에서 내가 잘 알지 못하는 측면은 무엇인가요?&lt;/li&gt;
&lt;li&gt;이 주제에 대해 관리자 및 기타 관련 담당자와 명확하게 커뮤니케이션하고 있습니까? 그들은 내가 원하는 것을 알고 있습니까? 이러한 질문에 대해 깊이 있는 답변으로 나에게 도움을 줄 수 있습니까?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;자신이 원하는 바와 관심사에 대해 더 많이 알게 될수록, 어떻게 하면 여러분이 현재 역할을 좀 더 잘 수행할 수 있을지에 대해 주변 사람들과 이야기하십시오. 그렇게 하면 여러분의 다음 경력에서 원하는 것을 위한 토대를 마련할 수 있을 것입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[스터디 정리] 하이퍼바이저의 종류</title>
      <link>https://lovejaco.github.io/posts/two-types-of-hypervisors/</link>
      <pubDate>Fri, 05 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://lovejaco.github.io/posts/two-types-of-hypervisors/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;프론트엔드 팀을 위한 CI/CD 라는 주제의 사내 스터디를 진행하며 발표 내용을 정리/요약한 글이며 참고 링크의 글을 그대로 인용하였습니다.
스터디 중에 동료가 베어메탈에 대한 질문을 하였습니다. 이에 따로 정리한 내용입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;베어메탈&#34;&gt;베어메탈&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.itworld.co.kr/t/62077/vdi/90854&#34;&gt;ITWorld 용어풀이 | 베어메탈 - ITWorld Korea&lt;/a&gt;&lt;br&gt;
IT 업계에서 사용하는 베어메탈의 의미는 “어떤 소프트웨어도 담겨 있지 않은 하드웨어”를 의미하며, 다른 관점에서는 “하드웨어만을 구매할 수 있는 제품”을 의미하기도 합니다. &lt;a href=&#34;http://www.itworld.co.kr/news/84523&#34;&gt;베어본 컴퓨터&lt;/a&gt; 와 일부 유사한 의미를 갖고 있습니다.&lt;/p&gt;
&lt;p&gt;물론 베어메탈이라는 용어는 이런 의미로 사용되고 있지만, 이 용어가 컴퓨팅 환경의 중요 용어로 부상한 것은 가상화 때문입니다. 가상화 아키텍처는 크게 두 가지로 분류하는데, 바로 호스트형 가상화와 베어메탈 가상화입니다. 말 그대로 호스트형 가상화는 하드웨어 상에 호스트 운영체제가 있고, 그 위에서 가상머신을 구현하는 방식입니다. 보통은 호스트 운영체제가 커널 수준에서 가상화 기술을 지원합니다.&lt;/p&gt;
&lt;p&gt;반면에 베어메탈 가상화는 호스트 운영체제없이 하드웨어 상에 하이퍼바이저가 바로 설치되고, 이 위에 가상머신을 구현하는 것입니다. 이런 하이퍼바이저를 베어메탈 하이퍼바이저라고 부릅니다. 현재 서버용 하이퍼바이저의 대부분은 베어메탈 하이퍼바이저이며, 데스크톱용 하이퍼바이저의 다수가 호스트형 하이퍼바이저입니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.shortpixel.ai/client/q_glossy,ret_img/https://www.pathpartnertech.com/wp-content/uploads/2020/02/hypervisors.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;하이퍼바이저&#34;&gt;하이퍼바이저&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.redhat.com/ko/topics/virtualization/what-is-a-hypervisor&#34;&gt;하이퍼바이저란?&lt;/a&gt;
하이퍼바이저는 &lt;a href=&#34;https://www.redhat.com/ko/topics/virtualization/what-is-a-virtual-machine&#34;&gt;가상 머신(Virtual Machine, VM)&lt;/a&gt; 을 생성하고 구동하는 소프트웨어입니다. 가상 머신 모니터(Virtual Machine Monitor, VMM)라고도 불리는 하이퍼바이저는 하이퍼바이저 운영 체제와 가상 머신의 리소스를 분리해 VM의 생성과 관리를 지원합니다.
하이퍼바이저로 사용되는 물리 하드웨어를 호스트라고 하며 리소스를 사용하는 여러 VM을 게스트라고 합니다.&lt;/p&gt;
&lt;p&gt;하이퍼바이저는 CPU, 메모리, 스토리지 등의 리소스를 처리하는 풀로, 기존 게스트 간 또는 새로운 가상 머신에 쉽게 재배치할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;하이퍼바이저-유형&#34;&gt;하이퍼바이저 유형&lt;/h3&gt;
&lt;p&gt;가상화에 사용할 수 있는 하이퍼바이저에는 유형 1과 유형 2 하이퍼바이저가 있습니다.&lt;/p&gt;
&lt;h4 id=&#34;유형-1&#34;&gt;유형 1&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://devopsunleashed.files.wordpress.com/2017/05/type1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;네이티브 또는 베어 메탈 하이퍼바이저라고도 불리는 유형 1 하이퍼바이저는 호스트의 하드웨어에서 직접 구동되어 게스트 운영 체제를 관리합니다. 호스트 운영 체제 대신 VM 리소스는 하이퍼바이저에 의해 하드웨어에 직접 예약됩니다.
이러한 유형의 하이퍼바이저는 엔터프라이즈 데이터 센터와 서버 기반 환경에서 가장 일반적으로 사용됩니다.&lt;/p&gt;
&lt;h4 id=&#34;유형-2&#34;&gt;유형 2&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://devopsunleashed.files.wordpress.com/2017/05/type2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;호스트 하이퍼바이저라고도 불리는 유형 2 하이퍼바이저는 기존의 운영 체제에서 소프트웨어 레이어 또는 애플리케이션으로서 구동됩니다.&lt;/p&gt;
&lt;p&gt;호스트 운영 체제에서 게스트 운영 체제를 추상화하는 방식으로 작동합니다. VM 리소스는 호스트 운영 체제에 따라 예약된 후 하드웨어에 대해 실행됩니다.&lt;/p&gt;
&lt;p&gt;유형 2 하이퍼바이저는 개인 컴퓨터에서 여러 개의 운영 체제를 구동하려는 개인 사용자에게 이상적입니다.
VMware Workstation과 Oracle VirtualBox는 유형 2 하이퍼바이저의 예입니다.&lt;/p&gt;
&lt;h2 id=&#34;추가-링크&#34;&gt;[추가 링크]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ciokorea.com/news/36713&#34;&gt;‘SW와 HW의 분리’··· 하이퍼바이저의 이해 - CIO Korea&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ciokorea.com/news/35402&#34;&gt;IBM 기고 | 클라우드를 좀 더 쉽게, 베어메탈(Bare Metal) - CIO Korea&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.docker.com/blog/containers-replacing-virtual-machines/&#34;&gt;Are Containers Replacing Virtual Machines? - Docker Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.stratoscale.com/blog/data-center/running-containers-on-bare-metal/&#34;&gt;Running Containers on Bare Metal vs. VMs: Performance and Benefits -&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nextplatform.com/2018/09/05/future-clouds-could-be-just-containers-on-bare-metal/&#34;&gt;Future Clouds Could Be Just Containers On Bare Metal&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[스터디 정리] CI/CD 개념 요약</title>
      <link>https://lovejaco.github.io/posts/what-is-ci-cd/</link>
      <pubDate>Thu, 04 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://lovejaco.github.io/posts/what-is-ci-cd/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;프론트엔드 팀을 위한 CI/CD 라는 주제의 사내 스터디를 진행하며 발표 내용을 정리/요약한 글이며 참고 링크의 글을 그대로 인용하였습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;what-is-ci--cd&#34;&gt;What is CI / CD&lt;/h2&gt;
&lt;p&gt;CI/CD는 애플리케이션 개발 단계를 &lt;a href=&#34;https://www.redhat.com/ko/topics/automation/whats-it-automation&#34;&gt;자동화&lt;/a&gt; 하여 애플리케이션을 보다 짧은 주기로 고객에게 제공하는 방법입니다. CI/CD의 기본 개념은 지속적인 통합, 지속적인 서비스 제공, 지속적인 배포입니다. CI/CD는 새로운 코드 통합으로 인해 개발 및 운영팀에 발생하는 문제(일명 “ &lt;a href=&#34;https://www.solutionsiq.com/agile-glossary/integration-hell/&#34;&gt;인테그레이션 헬(integration hell)&lt;/a&gt; “)을 해결하기 위한 솔루션입니다.&lt;/p&gt;
&lt;h3 id=&#34;지속적-통합continuous-integration&#34;&gt;지속적 통합(Continuous integration)&lt;/h3&gt;
&lt;p&gt;지속적인 통합을 수행하는 개발자는 변경 사항을 가능한 자주 main-line 브랜치로 병합합니다. 빌드를 작성하고 빌드에 대해 자동화된 테스트를 실행하여 개발자의 변경 사항을 검증합니다. 이렇게 하면 릴리스 일정에 따라 변경사항을 릴리스 브랜치에 병합하려 할 때 일반적으로 발생하는 통합 지옥을 피할 수 있습니다.&lt;/p&gt;
&lt;p&gt;지속적인 통합은 새로운 커밋이 메인 브랜치에 통합될 때마다 애플리케이션이 중단되지 않는지 확인하기 위해 테스트 자동화에 중점을 둡니다.&lt;/p&gt;
&lt;h3 id=&#34;지속적-전달-또는-제공continuous-delivery&#34;&gt;지속적 전달 또는 제공(Continuous delivery)&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.atlassian.com/continuous-delivery&#34;&gt;continuous-delivery&lt;/a&gt;는 지속적인 통합을 확장하여 고객에게 새로운 변경 사항을 지속 가능한 방식으로 신속하게 릴리스할 수 있도록 합니다. 개발자들이 애플리케이션에 적용한 변경 사항이 버그 테스트를 거쳐 리포지토리(예: &lt;a href=&#34;https://redhatofficial.github.io/#!/main&#34;&gt;GitHub&lt;/a&gt; 또는 컨테이너 레지스트리)에 자동으로 업로드되는 것을 뜻하며, 운영팀은 이 리포지토리에서 애플리케이션을 실시간 프로덕션 환경으로 배포할 수 있습니다. 이는 개발팀과 비즈니스팀 간의 가시성과 커뮤니케이션 부족 문제를 해결해 줍니다. 지속적인 제공은 최소한의 노력으로 새로운 코드를 배포하는 것을 목표로 합니다.&lt;/p&gt;
&lt;p&gt;이론적으로 지속적으로 전달하면 매일, 매주, 격주로 또는 비즈니스 요구 사항에 맞는 것을 릴리스하기로 결정할 수 있습니다. 그러나 지속적인 제공의 이점을 실제로 얻으려면 가능한 한 빨리 프로덕션에 배포하여 문제 발생 시 문제 해결이 쉬운 작은 배치를 릴리스해야 합니다.&lt;/p&gt;
&lt;h3 id=&#34;지속적-배포continuous-deployment&#34;&gt;지속적 배포(Continuous deployment)&lt;/h3&gt;
&lt;p&gt;Continuous Deployment(또 다른 의미의 “CD”)는 Continuous delivery 보다 한 단계 더 발전합니다.
개발자의 변경 사항을 리포지토리에서 고객이 사용 가능한 프로덕션 환경까지 자동으로 릴리스하는 것을 의미합니다. 이는 애플리케이션 제공 속도를 저해하는 수동 프로세스로 인한 운영팀의 프로세스 과부하 문제를 해결합니다. 지속적인 배포는 파이프라인의 다음 단계를 자동화함으로써 지속적인 제공이 가진 장점을 활용합니다.&lt;/p&gt;
&lt;p&gt;지속적인 배포는 더 이상 &lt;strong&gt;출시일&lt;/strong&gt; 이 없으므로 고객과의 피드백 루프를 가속화하고 팀을 압박할 수 있는 훌륭한 방법 입니다. 개발자는 소프트웨어 제작에 집중할 수 있으며, 작업을 마치고 몇 분 후에 작업이 진행되는 것을 볼 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.redhat.com/cms/managed-files/ci-cd-flow-desktop_1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CI/CD는 지속적 통합 및 지속적 제공의 구축 사례만을 지칭할 때도 있고, 지속적 통합, 지속적 제공, 지속적 배포라는 3가지 구축 사례 모두를 의미하는 것일 수도 있습니다. 좀 더 복잡하게 설명하면 “지속적인 서비스 제공”은 때로 지속적인 배포의 과정까지 포함하는 방식으로 사용되기도 합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;integration-hellhttpc2comxpintegrationhellhtml&#34;&gt;&lt;a href=&#34;http://c2.com/xp/IntegrationHell.html&#34;&gt;Integration Hell&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;현대적인 애플리케이션 개발에서는 여러 개발자들이 동일한 애플리케이션의 각기 다른 기능을 동시에 작업할 수 있도록 하는 것을 목표로 합니다. 그러나 특정한 날(“ &lt;a href=&#34;https://thedailywtf.com/articles/Happy_Merge_Day!&#34;&gt;병합(머지) 하는 날(merge day)&lt;/a&gt; “)을 정해 모든 분기 소스 코드를 병합하는 경우, 결과적으로 반복적인 수작업에 많은 시간을 소모하게 됩니다. 이렇게 하는 이유는 개발자가 애플리케이션에 변경 사항을 적용할 때 다른 개발자가 적용하는 변경 사항과 충돌할 가능성이 있기 때문입니다. 각 개발자가 각자의 로컬 IDE를 커스터마이징하는 경우 더욱 복합적인 문제가 될 수 있습니다.&lt;/p&gt;
&lt;p&gt;[참고 링크]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment&#34;&gt;Continuous integration vs. continuous delivery vs. continuous deployment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.redhat.com/ko/topics/devops/what-is-ci-cd&#34;&gt;CI/CD(지속적 통합/지속적 제공): 개념, 방법, 장점, 구현 과정&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/ko/devops/continuous-delivery/&#34;&gt;지속적 전달이란 무엇입니까? - Amazon Web Services&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>WebRTC 연결성 및 NAT 통과 기법</title>
      <link>https://lovejaco.github.io/posts/webrtc-connectivity-and-nat-traversal/</link>
      <pubDate>Wed, 03 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://lovejaco.github.io/posts/webrtc-connectivity-and-nat-traversal/</guid>
      <description>&lt;p&gt;이 게시물은 WebRTC 연결성 및 NAT 통과 기법이라는 주제의 사내 발표 내용을 정리한 글입니다.&lt;/p&gt;
&lt;h2 id=&#34;들어가며&#34;&gt;들어가며&lt;/h2&gt;
&lt;p&gt;WebRTC 프로젝트를 시작하려 할때 처음 마주하게 되는것은 아마도 시그널링, SDP, STUN, TURN과 같은 생소한 용어들과 RTCPeerConnection, RTCSessionDescription, RTCIceCandidate 와 같은 WebRTC API를 다루는 코드입니다.&lt;/p&gt;
&lt;p&gt;예제 코드를 작성하기에 앞서 WebRTC 앞에 놓인 인터넷 환경과 (p2p) 연결의 한계, 그리고 이를 극복하기 위한 방법과 원리에 대해 설명 하려고 합니다.&lt;/p&gt;
&lt;h2 id=&#34;what-is-webrtc&#34;&gt;What is WebRTC?&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://lh5.googleusercontent.com/RfgFLvUI1dpj19XnfQDia6CbyTkC6PRBs0ZhGm8RJPvTMbKcb6tiBqbKbPFW-oVoTx8j4KbLmanpj0yuV8_-yJOT_JM_z0P_MdQpohWco_s7RFfD690CqwngnQjO_M9BvdqiAwu9Prc&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ko.wikipedia.org/wiki/WebRTC&#34;&gt;WebRTC(Web Realtime Communications)&lt;/a&gt;는 웹 브라우저 간에 플러그인 없이 직접적으로(p2p) 통신할 수 있도록 설계된 API 입니다. W3C 에서 제시된 초안이며, 음성 통화, 영상 통화, P2P 파일 공유 등으로 활용될 수 있습니다&lt;/p&gt;
&lt;h2 id=&#34;websocket-vs-webrtc&#34;&gt;WebSocket vs WebRTC&lt;/h2&gt;
&lt;p&gt;WebSocket과 WebRTC 모두 양 방향(bi-directional) 및 &lt;a href=&#34;https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A4%91%ED%86%B5%EC%8B%A0&#34;&gt;전이중 통신: full-duplex&lt;/a&gt; 을 지원 한다는 공통점을 가지고 있습니다. 간단히 차이점에 대해 비교합니다.&lt;/p&gt;
&lt;h3 id=&#34;websocket&#34;&gt;WebSocket&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A Client Server Archetecture&lt;/li&gt;
&lt;li&gt;Runs Over TCP&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;webrtc&#34;&gt;WebRTC&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;allowing direct &lt;a href=&#34;https://ko.wikipedia.org/wiki/P2P&#34;&gt;peer-to-peer&lt;/a&gt; communication,&lt;/li&gt;
&lt;li&gt;Runs Over UDP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://bloggeek.me/wp-content/uploads/2019/05/201905-websocket-vs-datachannel.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;media-over-a-websocket&#34;&gt;Media over a WebSocket&lt;/h3&gt;
&lt;p&gt;WebRTC DataChannel과 마찬가지로 WebSocket 역시 “arraybuffer” 또는 “blob”과 같은 바이너리 형식을 지원하지만 &lt;a href=&#34;https://en.wikipedia.org/wiki/Real-time_communication&#34;&gt;Real-time communication&lt;/a&gt; 데이터를 처리하기에는 적절하지 않습니다.&lt;/p&gt;
&lt;p&gt;대부분의 경우 실시간 미디어는 WebRTC 또는 RTSP, RTMP, HLS 등과 같은 다른 프로토콜을 통해 전송됩니다.&lt;/p&gt;
&lt;h3 id=&#34;webrtc-media-transport-and-use-of-rtp&#34;&gt;WebRTC: Media Transport and Use of RTP&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://hpbn.co/assets/diagrams/f91164cbbb944d8986c90a1e93afcd82.svg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;WebRTC는 RTP 프로토콜을 이용하여 미디어를 교환합니다. &lt;a href=&#34;https://tools.ietf.org/html/draft-ietf-rtcweb-rtp-usage-26&#34;&gt;Web Real-Time Communication (WebRTC: Media Transport and Use of RTP&lt;/a&gt;는 WebRTC에서 실시간 전송 프로토콜 (RTP)이 사용되는 방법과 RTP 기능에 대한 요구 사항을 제공합니다.&lt;/p&gt;
&lt;h3 id=&#34;실시간-전송-프로토콜-rtp&#34;&gt;실시간 전송 프로토콜 (RTP)&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://ko.wikipedia.org/wiki/%EC%8B%A4%EC%8B%9C%EA%B0%84_%EC%A0%84%EC%86%A1_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C&#34;&gt;실시간 전송 프로토콜(Real-time Transport Protocol, RTP)&lt;/a&gt;은 IP 네트워크 상에서 오디오와 비디오를 전달하기 위한 통신 프로토콜 입니다. RTP는 전화, WebRTC, 텔레비전 서비스, 웹 기반 푸시 투 토크 기능을 포함한 화상 통화 분야 등의 스트리밍 미디어를 수반하는 통신, 엔터테인먼트 시스템에 사용됩니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lh6.googleusercontent.com/XCvjkQoMEPNWn8ama4iiO92bvcChyzGFZijcRDFu37m0GFMfNZMdijZHXqT3F7_OzDAmVfzvPM_TKFbhjgBku87rJfXxi4bhafX3jCMdOoQk-YTAm84_wdjVRx8ROkaD_1zz_lwvVm4&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;RTP는 일반적으로 사용자 데이터그램 프로토콜(UDP)로 동작하며, RTP는 RTCP(RTP Control Protocol)와 결합하여 사용됩니다.&lt;/p&gt;
&lt;h2 id=&#34;webrtc-연결성-connectivity&#34;&gt;WebRTC 연결성 (connectivity)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Connectivity&#34;&gt;WebRTC connectivity - MDN&lt;/a&gt;에서 다양한 WebRTC 관련 프로토콜이 피어 간의 연결을 만들고 데이터 및 미디어를 전송하기 위해 상호 작용하는 방법을 설명합니다.&lt;/p&gt;
&lt;p&gt;그전에, 이런 절차가 왜? 필요한지에 관해 알아보려 합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imagescdn.gettyimagesbank.com/500/18/288/575/0/1030419304.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;온라인에서 모르는 누군가와 (p2p) 연결을 시도하는 것은 오프라인에서 연락처를 교환하고 서로 통화를 시도하는 과정과 유사합니다.&lt;/p&gt;
&lt;h3 id=&#34;온라인-식별&#34;&gt;온라인 식별&lt;/h3&gt;
&lt;p&gt;전화번호를 이용하여 상대방을 식별하는 것과 마찬가지로 인터넷 환경에서는 IP 주소를 이용합니다.&lt;/p&gt;
&lt;h4 id=&#34;공인-ip-사설-ip-고정-ip-유동-ip&#34;&gt;공인 IP, 사설 IP, 고정 IP, 유동 IP&lt;/h4&gt;
&lt;p&gt;피어간 연결을 위해서 상대의 IP 주소를 알아야 합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;공인 IP: 관리 기관에서 부여한 전세계에서 &lt;strong&gt;유일한&lt;/strong&gt; IP&lt;strong&gt;주소&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;사설 IP: 임의로 부여한 IP, 자신의 네트워크 안에서만 &lt;strong&gt;유일한&lt;/strong&gt; IP&lt;strong&gt;주소&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;고정 IP: IP를 반납하기 전까지는 다른 장비에 부여할수 없는 IP&lt;/li&gt;
&lt;li&gt;유동 IP: 사용할 때 남아있는 IP 중에서 부여하는 IP&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;signaling&#34;&gt;Signaling&lt;/h3&gt;
&lt;p&gt;누군가 나의 전화번호를 이용하여 연결을 시도하면 내 전화기의 전화벨이 울리고 상대방은 대기합니다. 저는 이 연결을 수락할 수도 있고 거부할 수도 있습니다. 때로는 시간 초과로 연결이 실패할 수도 있습니다.
이처럼 통신 세션을 설정, 제어, 종료하는 프로세스를 시그널링이라고 부릅니다.&lt;/p&gt;
&lt;p&gt;p2p 연결은 ip:port를 open 하거나 listen 함으로서 동작합니다. 따라서 사전에 상호 간 연결 설정을 교환하고 동의해야 합니다.&lt;/p&gt;
&lt;h3 id=&#34;natfirewall-problem&#34;&gt;NAT/Firewall Problem&lt;/h3&gt;
&lt;p&gt;IP 주소를 알고 있고, 연결할 준비가 되었다고 해서 늘 연결에 성공하는 것은 아닙니다. 공유기와 같은 라우터 장비 내부에 있는 디바이스는 p2p 연결에 어려움을 겪습니다.&lt;/p&gt;
&lt;h2 id=&#34;nat-network-address-translation&#34;&gt;NAT (Network Address Translation)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://ko.wikipedia.org/wiki/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_%EC%A3%BC%EC%86%8C_%EB%B3%80%ED%99%98&#34;&gt;네트워크 주소 변환(영어: network address translation, 줄여서 NAT)&lt;/a&gt;은 컴퓨터 네트워킹에서 쓰이는 용어로서, IP 패킷의 TCP/UDP 포트 숫자와 소스 및 목적지의 IP 주소 등을 재기록하면서 라우터를 통해 네트워크 트래픽을 주고 받는 기술을 말합니다.&lt;/p&gt;
&lt;p&gt;가정용 라우터(공유기)와 같이 NAT(Network Address Translation)는 라우터의 일부로서, 그리고 통합된 방화벽의 일부로서 한번에 두가지 문제를 처리합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/W44dghqO284h-65OyhXeKgrqpsrKy0g4OdXE6DCI6ZYd6zLXUGv75bqyPA1iGcNI3Siqx1RJ1jQqy_o6-fYRxiw9Zx7wYv90hDuCl3QhXZKMCjNe--kqt5J1oIQU0V-i_Wl4V_r_GMU&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;인터넷 공인(Publid) IP 주소는 한정되어 있기 때문에 NAT는 사설(Private) IP를 사용하면서 이를 공인 IP로 상호변환할수 있도록 지원 합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ltwus2ix28x10gixx34jeigv-wpengine.netdna-ssl.com/wp-content/uploads/2013/08/NAT-post-image-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;공개된 인터넷과 사설망 사이에 방화벽을 설치하여 외부 공격으로부터 네트워크를 보호하는 수단으로 사용됩니다.&lt;/p&gt;
&lt;h3 id=&#34;일반적인-nat-시나리오&#34;&gt;일반적인 NAT 시나리오&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://lh5.googleusercontent.com/UEU4ipyrC9ObBe6P4WstA8klYEpcUTA-sCrO8lzCNYajODZMhLBP3-GTzjl3B0OWB4HuPsSw8Vjj9qAWqZgAR_Hd-YSE0xRcOgyOYCYzQ3rbzXvHz26hiWINIt3WLmDS2hrgd48-J1o&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;대부분의 방화벽은 인터넷의 특정 패킷이 NAT를 통과하도록 허용하지만, 호스트가 먼저 방화벽을 통해 패킷을 내보낸 경우에만 가능합니다. 본질적으로 통신은 LAN의 호스트에 의해 시작되어야 합니다.&lt;/p&gt;
&lt;p&gt;모든 패킷에는 5개의 튜플로 이루어진 TCP/IP 정보로 구성되어 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;source [ip:port], destination[ip:port], transport protocol&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;패킷이 NAT/방화벽 장치를 통과하면 소스 IP 및 소스 포트가 새로운 소스 IP 및 소스 포트로 변경됩니다. 그런 다음 “내부” 소스 IP 및 소스 포트와 “외부” 소스 IP 및 소스 포트 사이의 바인딩(이를 NAT 바인딩이라고 하며) 정보를 테이블에 저장합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ltwus2ix28x10gixx34jeigv-wpengine.netdna-ssl.com/wp-content/uploads/2013/08/NAT-post-image-3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;인터넷에 있는 호스트는 변경된 “외부” IP:Port만 알 수 있습니다. 호스트가 이 “외부” IP:Port를 확인하고 이 주소로 패킷을 보내면 먼저 NAT/방화벽 장치로 도착합니다. NAT/방화벽 장치는 NAT 테이블을 조회한 다음, NAT 바인딩을 기반으로 대상(target) IP:Port를 변경하고 패킷을 내부 호스트로 전달합니다.&lt;/p&gt;
&lt;h3 id=&#34;nats-and-peer-to-peer&#34;&gt;NATs and Peer-to-Peer&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://ltwus2ix28x10gixx34jeigv-wpengine.netdna-ssl.com/wp-content/uploads/2013/08/NAT-post-image-4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;클라이언트 - 서버 간 통신은 NAT/방화벽을 잘 통화하지만 p2p 연결에는 어려움이 따릅니다. 각 엔드포인트 사이에 NAT/방화벽 장치가 존재할 가능성이 있기 때문입니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ltwus2ix28x10gixx34jeigv-wpengine.netdna-ssl.com/wp-content/uploads/2013/08/NAT-post-image-5.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;엔드포인트는 자신과 통신하려는 피어 사이에 어떤 종류의 네트워크 토폴로지(링크, 노드의 요소들)가 있는지 알 수있는 방법이 없습니다. 따라서, 로컬 호스트에서 전송한 패킷이 방화벽에 의해 차단 되는 것을 알지 못하며, 추가적으로 엔드포인트에 의해 제출된 주소는 그 사이에 있는 NAT 때문에 다른 피어가 연결할 수 조차 없습니다.&lt;/p&gt;
&lt;h2 id=&#34;nat를-넘어-p2p-연결하기&#34;&gt;NAT를 넘어 P2P 연결하기&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Relaying&lt;/li&gt;
&lt;li&gt;Connection Reversal&lt;/li&gt;
&lt;li&gt;Hole Punching
&lt;ol&gt;
&lt;li&gt;UDP&lt;/li&gt;
&lt;li&gt;TCP&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;relaying&#34;&gt;Relaying&lt;/h3&gt;
&lt;p&gt;Relaying 방법은 사설 IP 주소를 가지는 두 단말 간에 직접 통신을 할 수 없다면 공인 IP 주소를 가지는 외부 서버를 통해 P2P 데이터 패킷을 Relay하자는 개념입니다.&lt;/p&gt;
&lt;h3 id=&#34;connection-reversal&#34;&gt;Connection Reversal&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://bford.info/pub/net/p2pnat/img7.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;두 호스트 모두 잘 알려진 서버에 연결되어 있고 피어 중 하나만 NAT 뒤에있을 때 통신을 가능하게하기 위해 연결 반전이라고 알려진 간단하지만 제한된 기술을 사용합니다. B가 A에 대한 연결을 시작하려는 경우 A에 대한 모든 직접 연결 시도는 A의 NAT에 의해 차단됩니다. 대신 서버 S를 통해 A로 연결 요청을 릴레이하여 A에게 B로의 &amp;ldquo;역방향&amp;rdquo; 연결을 다시 시도하도록 요청합니다. 이 아이디어는 기술적인 한계에도 불구하고, 다음에 설명하는 일반적인 홀 펀칭 기술의 기초가 됩니다.&lt;/p&gt;
&lt;h3 id=&#34;hole-puncing&#34;&gt;Hole Puncing&lt;/h3&gt;
&lt;p&gt;P2P 통신을 목적으로 Routing Table 을 작성하기 위해 사전에 상대방과 패킷을
주고받게 하여 각자의 공유기에 Routing Table을 작성하는 것을 홀 펀칭이라고 합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.researchgate.net/profile/Wilhelm_Hasselbring/publication/250030374/figure/fig2/AS:298352580284420@1448144206583/Simplified-hole-punching-example.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;흔히 &lt;a href=&#34;https://en.wikipedia.org/wiki/UDP_hole_punching&#34;&gt;UDP 홀펀칭&lt;/a&gt; 으로 널리 알려졌지만, &lt;a href=&#34;https://en.wikipedia.org/wiki/TCP_hole_punching&#34;&gt;TCP에 대해서도 적용할 수 있습니다.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bford.info/pub/net/p2pnat/img8.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;자세한 설명은 다음의 링크에서 확인할 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bford.info/pub/net/p2pnat/&#34;&gt;– Bryan Ford’s Home Page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.netmanias.com/ko/post/blog/6263/nat-network-protocol-p2p/p2p-nat-nat-traversal-technic-rfc-5128-part-2-udp-hole-punching&#34;&gt;P2P와 NAT: NAT 통과 기법 소개 (RFC 5128) - 2편: UDP Hole Punching | NETMANIAS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;webrtc-tools-for-natfirewall-traversal&#34;&gt;WebRTC tools for NAT/Firewall Traversal&lt;/h2&gt;
&lt;p&gt;WebRTC는 NAT 통과 기법을 위해 다음의 네트워크 표준을 이용합니다.
이 표준들은 위에서 설명한 P2P 연결 방법에 대한 구체적이고 표준화된 연결 방법입니다.&lt;/p&gt;
&lt;h3 id=&#34;interactive-connectivity-establishment-ice--rfc-5245&#34;&gt;Interactive Connectivity Establishment (ICE) – RFC 5245&lt;/h3&gt;
&lt;h4 id=&#34;시그널링&#34;&gt;시그널링&lt;/h4&gt;
&lt;p&gt;WebRTC에서 서로 다른 네트워크에 있는 2개의 디바이스들을 서로 연결하기 위해서는, 각 디바이스들의 위치를 발견하는 방법과 미디어 포맷 협의가 필요합니다. 이 프로세스를 &lt;strong&gt;시그널링&lt;/strong&gt; &lt;strong&gt;signaling&lt;/strong&gt;이라 부르고 상호 간에 동의된 서버에 연결합니다. 이 서버는 각 디바이스들이 &lt;strong&gt;negotiation&lt;/strong&gt;(협상) 메시지들을 교환할 수 있도록 중개합니다.&lt;/p&gt;
&lt;h4 id=&#34;the-signaling-server&#34;&gt;The signaling server&lt;/h4&gt;
&lt;p&gt;WebRTC는 시그널링 정보에 관한 transport 메커니즘을 제시하지 않습니다. 두 피어들 사이에서 정보를 전달해 줄 수 있는 것이라면 어떤 것이든 상관 없습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;XMLHttpRequest&lt;/li&gt;
&lt;li&gt;long polling&lt;/li&gt;
&lt;li&gt;WebSocket&lt;/li&gt;
&lt;li&gt;MQTT Over WebSocket&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;시그널링 서버는 SDP를 전달하지만 데이터 내용은 몰라도 됩니다. 메시지의 내용들은 각 피어에서 생성되고 시그널링 서버를 통해 상대편으로 전송 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;session-description-protocol-sdp&#34;&gt;Session Description Protocol (SDP)&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://ko.wikipedia.org/wiki/%EC%84%B8%EC%85%98_%EA%B8%B0%EC%88%A0_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C&#34;&gt;세션 기술 프로토콜 - SDP&lt;/a&gt;은 스트리밍 미디어의 초기화 인수를 기술하기 위한 포맷으로. 이 규격은 IETF의 RFC 4566로 규정되어 있습니다.&lt;/p&gt;
&lt;p&gt;SDP는 해상도, 형식, 코덱, 암호화등의 멀티미디어 컨텐츠의 연결을 기술(Description)하기 위한 표준 입니다. 기술적으로는, 실제 프로토콜이 아니라 장치간에 미디어를 공유하는 연결을 설명하는데 사용되는 데이터 형식입니다.&lt;/p&gt;
&lt;h3 id=&#34;ice-candidates&#34;&gt;ICE candidates&lt;/h3&gt;
&lt;p&gt;피어는 (위에서 설명한 SDP로) 미디어에 대한 정보를 교환 할뿐만 아니라 네트워크 연결에 대한 정보를 교환해야합니다. 이를 ICE candidates라고 하며 피어가(직접적으로 또는 TURN 서버를 통해 경유하여) 사용 가능한 방법을 자세히 설명합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;예를 들어 연락처를 교환할때 보통은 휴대폰 번호만을 주고받는것이 일반적이지만, 필요에 따라 집 또는 직장 번호를 교환하기도 합니다. 이 처럼 통화 가능한 연락처의 목록을 ICE candidates (ip, port, transport) 라고 부르며, 피어가 능동적으로 이 후보들을 설명합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;일반적으로 각각의 피어는 가장 좋은 후보에서 나쁜 후보 순서로 제안하고 연결을 위해 나아가게 됩니다. UDP 후보가(더 빠르고, 미디어 스트림이 비교적 쉽게 인터럽트로부터 회복할 수 있기 때문에) 이상적이지만, ICE 표준은 TCP 후보 역시 허용합니다.&lt;/p&gt;
&lt;h4 id=&#34;rtcicecandidatetype&#34;&gt;RTCIceCandidateType&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;host
호스트 후보는 호스트의 인터페이스(VPN 인터페이스를 포함하여 물리적 또는 가상)에 연결된 실제 IP 주소 입니다.&lt;/li&gt;
&lt;li&gt;srflx
server reflexive candidate는 STUN / TURN 서버에 의해 식별된 IP 주소로, 클라이언트의 공인 IP 주소 입니다.&lt;/li&gt;
&lt;li&gt;prflx
peer reflexive candidate는 각 피어에 의해 식별된 IP 주소, 각 피어간 STUN Check를 통하여 식별된 IP 주소입니다.&lt;/li&gt;
&lt;li&gt;relay
relay candidate는 server reflexive candidate( &amp;ldquo;srflx&amp;rdquo;)처럼 생성되지만 STUN 대신 TURN을 사용합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;session-traversal-utilities-for-nat-stun--rfc-5389&#34;&gt;Session Traversal Utilities for NAT (STUN) – RFC 5389&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://d20hvw4zeymqbm.cloudfront.net/wp-content/uploads/2013/09/stun.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/STUN&#34;&gt;Session Traversal Utilities for NAT (STUN)&lt;/a&gt;은 P2P 통신을 위해 호스트가 NAT의 존재 유무 및 NAT 타입을 식별(discover)하고 또한 NAT에 의해 변경되는 외부 IP 주소 및 Port 값을 발견하기 위한 네트워크 프로토콜입니다.&lt;/p&gt;
&lt;p&gt;STUN은 클라이언트-서버 프로토콜입니다. STUN 클라이언트는 공용 IP 및 포트를 발견하기 위해 STUN 서버에 요청을 보내고 STUN 서버는 응답을 리턴합니다. 요청에는 일반적으로 UDP를 통해 전송되는 Binding Request와 TCP 와 TLS (보안 통신) 를 통해 전송되는 Shared Secret Request입니다.&lt;/p&gt;
&lt;p&gt;stun message type&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0x0001 : Binding Request&lt;/li&gt;
&lt;li&gt;0x0101 : Binding Response&lt;/li&gt;
&lt;li&gt;0x0111 : Binding Error Response&lt;/li&gt;
&lt;li&gt;0x0002 : Shared Secret Request&lt;/li&gt;
&lt;li&gt;0x0102 : Shared Secret Response&lt;/li&gt;
&lt;li&gt;0x0112 : Shared Secret Error Response&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;traversal-using-relay-nat-turn--rfc-5766&#34;&gt;Traversal Using Relay NAT (TURN) – RFC 5766&lt;/h3&gt;
&lt;p&gt;위에서 Relaying에 대해 설명한것과 마찬가지로 WebRTC 역시 공인 IP 주소를 가지는 외부 서버를 통해 P2P 데이터 패킷을 Relay 하는데 이를 TURN이라고 부릅니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img.favpng.com/7/5/3/traversal-using-relays-around-nat-stun-nat-traversal-computer-servers-webrtc-png-favpng-mQRBjt11JcX3SKAL9YixwsCLZ.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;몇몇의 라우터들은 Symmetric NAT이라고 불리우는 NAT를 채용하고 있습니다. &lt;a href=&#34;http://en.wikipedia.org/wiki/TURN&#34;&gt;Traversal Using Relays around NAT (TURN)&lt;/a&gt; 은 TURN 서버와 연결하고 모든 정보를 서버에 전달하는 것으로 Symmetric NAT 제한을 우회하는 것을 의미합니다. 이것은 명백히 오버헤드가 발생하므로 이 방법은 다른 대안이 없을 경우만 사용하게 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.frozenmountain.com/hs-fs/hubfs/4%20-%20blog%20images/Turn%20Stun%20chart.png?width=1490&amp;amp;name=Turn%20Stun%20chart.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;webrtc-call-flow-호출-흐름---api&#34;&gt;WebRTC Call Flow (호출 흐름) - API&lt;/h2&gt;
&lt;p&gt;이제 WebRTC 의 연결 흐름에 대해 알아 보겠습니다.&lt;/p&gt;
&lt;h3 id=&#34;signalling&#34;&gt;Signalling&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;configs&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
  &lt;span style=&#34;color:#a6e22e&#34;&gt;iceServers&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; [
    {
      &lt;span style=&#34;color:#a6e22e&#34;&gt;urls&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;stun:stun.l.google.com:19302&amp;#34;&lt;/span&gt;,
    },
    {
      &lt;span style=&#34;color:#a6e22e&#34;&gt;urls&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;turn:192.158.29.39:3478?transport=udp&amp;#34;&lt;/span&gt;,
      &lt;span style=&#34;color:#a6e22e&#34;&gt;credential&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;JZEOEt2V3Qb0y27GRntt2u2PAYA=&amp;#34;&lt;/span&gt;,
      &lt;span style=&#34;color:#a6e22e&#34;&gt;username&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;28224511:1379330808&amp;#34;&lt;/span&gt;,
    },
    {
      &lt;span style=&#34;color:#a6e22e&#34;&gt;urls&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;turn:192.158.29.39:3478?transport=tcp&amp;#34;&lt;/span&gt;,
      &lt;span style=&#34;color:#a6e22e&#34;&gt;credential&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;JZEOEt2V3Qb0y27GRntt2u2PAYA=&amp;#34;&lt;/span&gt;,
      &lt;span style=&#34;color:#a6e22e&#34;&gt;username&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;28224511:1379330808&amp;#34;&lt;/span&gt;,
    },
  ],
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;peerConnectionOptions&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
  &lt;span style=&#34;color:#a6e22e&#34;&gt;optional&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; [
    {
      &lt;span style=&#34;color:#a6e22e&#34;&gt;DtlsSrtpKeyAgreement&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;,
    },
  ],
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;myPeerConnection&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;RTCPeerConnection&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;configs&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;peerConnectionOptions&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://www.html5rocks.com/ko/tutorials/webrtc/infrastructure/turn.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;RTCPeerConnection 설정에 따라 STUN/TURN 서버의 구성이 변경될 수 있습니다.&lt;/p&gt;
&lt;h4 id=&#34;offer--answer&#34;&gt;Offer / Answer&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://hpbn.co/assets/diagrams/69aa329ffbfae6fd0446de77623c93fb.svg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;offer-sdp&#34;&gt;Offer SDP&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://lh4.googleusercontent.com/5MUbymu8G_iRPSn_ks-eLO8OH7DP6NW_rXMtp9BgWY29T4LZi-JVq2YOXuWey5lmEuCqihms-xzEi2RFUb1SblhtyxbhSyA7cOaAIwrrnolDBpTcQatVPGNBPIjEZr0XtFLXrISdQNc&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;myPeerConnection&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;createOffer&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;then&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;offer&lt;/span&gt;) {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;myPeerConnection&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;setLocalDescription&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;RTCSessionDescription&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;offer&lt;/span&gt;));
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;answer-sdp&#34;&gt;Answer SDP&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://lh6.googleusercontent.com/xQc7L7-RTOyNkVTIIjwR6fF_iPziPsyw9Fx3l_GGmN8rlh4l-11ylMHo-X0jg4b0L2k0R_cL9-HoKRGveaoq-v4HegwWqyB8jR5qpNB2Fl1m8MUXZXZmBzzZIgbK9oytd-BBUvgfatg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;myPeerConnection&lt;/span&gt;
  .&lt;span style=&#34;color:#a6e22e&#34;&gt;setRemoteDescription&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;RTCSessionDescription&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;description&lt;/span&gt;))
  .&lt;span style=&#34;color:#a6e22e&#34;&gt;then&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; () {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;createMyStream&lt;/span&gt;();
  });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;시그널 서버로부터 전달받은 상대의 remoteDescription을 등록합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn-images-1.medium.com/max/800/1*X4iOI4qIKwoC8oK7AFdr6w.jpeg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A: RTCPeerConnection.createOffer() 호출하여 제안(Offer) 형식(sdp 포맷)을 생성&lt;/li&gt;
&lt;li&gt;A: peerConnection.setLocalDescription(sdp) 생성된 제안을 peerConnection 객체에 등록&lt;/li&gt;
&lt;li&gt;A: send To SignalServer(sdp): &lt;strong&gt;sendOffer&lt;/strong&gt; 시그널 서버로 제안(SDP) 전송&lt;/li&gt;
&lt;li&gt;B: receive From SignalServer(sdp): &lt;strong&gt;receiveOffer&lt;/strong&gt; B가 시그널 서버로부터 제안(SDP)을 수신&lt;/li&gt;
&lt;li&gt;B: peerConnection.setRemoteDescription(sdp) B가 A의 제안(SDP)을 peerConnection 객체에 등록&lt;/li&gt;
&lt;li&gt;B: RTCPeerConnection.createAnswer(): B가 수락(Answer) 형식(sdp 포맷)을 생성&lt;/li&gt;
&lt;li&gt;B: peerConnection.setLocalDescription(sdp) 생성된 수락을 peerConnection 객체에 등록&lt;/li&gt;
&lt;li&gt;B: send To SignalServer(sdp): &lt;strong&gt;sendAnswer&lt;/strong&gt; 시그널 서버로 수락(SDP) 전송&lt;/li&gt;
&lt;li&gt;A: receive From SignalServer(sdp): &lt;strong&gt;receiveAnswer&lt;/strong&gt; A가 시그널 서버로 부터 B의 수락 형식을 수신&lt;/li&gt;
&lt;li&gt;A: peerConnection.setRemoteDescription(sdp) A가 B의 수락(SDP)을 peerConnection 객체에 등록&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;interactive-connectivity-establishment-ice&#34;&gt;Interactive Connectivity Establishment (ICE)&lt;/h3&gt;
&lt;p&gt;대화식 연결 설정&lt;/p&gt;
&lt;h4 id=&#34;ice-gathering&#34;&gt;Ice gathering&lt;/h4&gt;
&lt;p&gt;setLocalDescription 호출이 완료되면 피어는 자신의 ice 후보를 수집합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;pc&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;onicecandidate&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;event&lt;/span&gt;) {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;event&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;candidate&lt;/span&gt;) {
    &lt;span style=&#34;color:#75715e&#34;&gt;// event.candidate가 존재하면 원격 유저에게 candidate를 전달합니다.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
    &lt;span style=&#34;color:#75715e&#34;&gt;// 모든 ICE candidate가 원격 유저에게 전달된 조건에서 실행됩니다.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// candidate = null
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;exchange-ice-candidates&#34;&gt;Exchange Ice Candidates&lt;/h4&gt;
&lt;p&gt;각 피어는 식별된 자신의 ice candidates를 SDP에 패킹하거나 독립적으로 전송하도록 선택할 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SDP에 포함&lt;br&gt;
ICE 후보가 SDP 제안/응답에 포함될 수 있습니다. 이렇게 하려면 ICE 수집 프로세스가 완료 될 때까지 기다린 다음 SDP 제안 / 응답을 보내십시오.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TrickleICE&lt;br&gt;
&lt;strong&gt;ICE trickling&lt;/strong&gt; 은 초기 offer 혹은 answer를 다른 유저에게 이미 전달을 했음에도 계속해서 candidate를 보내는 과정을 뜻합니다. 이 속성은 &lt;a href=&#34;https://developer.mozilla.org/ko/docs/Web/API/RTCPeerConnection/setRemoteDescription&#34;&gt;RTCPeerConnection.setRemoteDescription()&lt;/a&gt;가 호출된 후에만 설정됩니다. TrickleICE가 구현 된 경우 (Chrome 및 Firefox) 첫 번째 양호한 ICE 후보가 발견되면 연결이 시작됩니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Trickle ICE는 시그널 채널을 통해 더 많은 트래픽을 생성하지만 p2p 연결을 시작하는데 필요한 시간이 크게 향상 될 수 있습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;signalingChannel&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;onmessage&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;receivedString&lt;/span&gt;) =&amp;gt; {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;JSON&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;parse&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;receivedString&lt;/span&gt;);
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;message&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ice&lt;/span&gt;) {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;pc&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;addIceCandidate&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;message&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ice&lt;/span&gt;).&lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;) =&amp;gt; {
      &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Failure during addIceCandidate(): &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;);
    });
  } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
    &lt;span style=&#34;color:#75715e&#34;&gt;// handle other things you might be signaling, like sdp
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Websocket등을 이용하여 시그널 서버로 전송하고, 전송받은 후보를 등록&lt;/p&gt;
&lt;h5 id=&#34;stun-check--dtls--rtp--sctp&#34;&gt;STUN Check / DTLS / RTP / SCTP&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://lh4.googleusercontent.com/Ag31x7cJXPixbM1pwasQil5zHDjJwhRqAe56CHUhOUgYalTqdL4_sRCJawEOF85m1KS2kzNkSY8mZlQuc9QXFTNLv8ml_Xci60rxwviDERQ-B9f0K5vGt79699ce88YtxshQoU68X48&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;전달받은 상대방의 연결 후보(IP 주소)를 이용하여 연결을 시도 합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;STUN&lt;br&gt;
STUN 프로토콜을 이용하여 확인 합니다.
서로 동시에 연결을 시도하는 경우 STUN 에러가 발생하기도 합니다. 그러나 프로토콜 흐름에 따라 한쪽에서 기다리고 다른 한쪽에서 연결을 시도하여 확인 합니다.&lt;/li&gt;
&lt;li&gt;DTLS&lt;br&gt;
STUN 연결이 확인되면 DTLS(보안 연결)을 이용하여 RTP 스트림에 사용되는 키를 설정합니다. &lt;a href=&#34;https://tools.ietf.org/html/rfc5764&#34;&gt;RFC 5764 - Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;RTCP&lt;br&gt;
&lt;a href=&#34;https://ko.wikipedia.org/wiki/RTCP&#34;&gt;RTCP&lt;/a&gt; 는 RTP 세션의 대역 외(out-of-band) 통계 및 제어 정보를 제공한다. 멀티미디어 데이터의 전달, 패키징 시에 RTP와 함께 사용하지만 RTCP가 직접 미디어 데이터를 전송하지는 않는다.&lt;/li&gt;
&lt;li&gt;RTP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;감사합니다.&lt;/p&gt;
&lt;p&gt;[참고 링크]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://webrtchacks.com/an-intro-to-webrtcs-natfirewall-problem/&#34;&gt;An Intro to WebRTC’s NAT/Firewall Problem - webrtcHacks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/ko/docs/Web/API/RTCPeerConnection&#34;&gt;RTCPeerConnection - Web API | MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Connectivity&#34;&gt;WebRTC connectivity - Web APIs | MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/ko/docs/Web/API/WebRTC_API/Signaling_and_video_calling&#34;&gt;Signaling and video calling - Web API | MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.frozenmountain.com/developers/blog/webrtc-nat-traversal-methods-a-case-for-embedded-turn&#34;&gt;WebRTC NAT Traversal Methods: A Case for Embedded TURN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bloggeek.me/webrtc-vs-websockets/&#34;&gt;WebRTC vs WebSockets • BlogGeek.me&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.educba.com/websockets-vs-webrtc/&#34;&gt;websockets vs webrtc | 7 Most Amazing Comparisons To Learn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hpbn.co/webrtc/&#34;&gt;Browser APIs and Protocols: WebRTC - High Performance Browser Networking(O’Reilly)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.html5rocks.com/ko/tutorials/webrtc/infrastructure/&#34;&gt;WebRTC in the real world: STUN, TURN and signaling - HTML5 Rocks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.3cx.com/pbx/what-is-a-stun-server/&#34;&gt;What is a STUN Server and how does it work?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/id/draft-ietf-ice-rfc5245bis-14.html&#34;&gt;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.onsip.com/voip-resources/voip-fundamentals/webrtc-signaling&#34;&gt;What is WebRTC Signaling?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://indigoo.com/petersblog/?p=215&#34;&gt;https://indigoo.com/petersblog/?p=215&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bford.info/pub/net/p2pnat/&#34;&gt;– Bryan Ford’s Home Page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://snack.planetarium.dev/kor/2019/04/nat_traversal_1/&#34;&gt;NAT를 넘어서 가자&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://snack.planetarium.dev/kor/2019/06/nat_traversal_2/&#34;&gt;예제로 보는 TURN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juyoung-1008.tistory.com/27&#34;&gt;안드로이드 WebRTC 시작하기 -3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>about</title>
      <link>https://lovejaco.github.io/about/</link>
      <pubDate>Thu, 28 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://lovejaco.github.io/about/</guid>
      <description>&lt;p&gt;번역 게시물은 번역기와 함께 주관적인 이해를 바탕으로 작성되어, 오역 가능성이 높습니다.
모든 번역 게시물의 저작권은 해당 원작자에게 있습니다.&lt;/p&gt;
&lt;p&gt;사내 공유를 목적으로 작성한 게시물들을 개인 블로그에 옮기는 작업을 진행 중입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>임성열</title>
      <link>https://lovejaco.github.io/contact/</link>
      <pubDate>Thu, 28 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://lovejaco.github.io/contact/</guid>
      <description>&lt;h3 id=&#34;contact-information&#34;&gt;Contact information&lt;/h3&gt;
&lt;p&gt;📩lovejaco@gmail.com&lt;/p&gt;
&lt;p&gt;💼 &lt;a href=&#34;http://www.linkedin.com/in/yim-sung-yeol-4921a767&#34;&gt;LinkedIn&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;project-experience&#34;&gt;Project experience&lt;/h1&gt;
&lt;h2 id=&#34;remoteseminarhttpswwwremoteseminarcomko&#34;&gt;🔗&lt;a href=&#34;https://www.remoteseminar.com/ko/&#34;&gt;RemoteSeminar&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;알서포트 (2019.04 - ) frontend&lt;/p&gt;
&lt;p&gt;웹 아키텍쳐, 프론트엔드 리드 개발, CI/CD 환경 구성 및 스크립트 개발/운영&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;React, Redux(saga), WebRTC, MQTT over WebSocket, canvas, git, gitlab-ci, docker, ansible, shell&lt;/p&gt;
&lt;p&gt;리모트 세미나 프로젝트는 WebRTC 기술을 사용하여 브라우저에서 화상 원격 세미나를 지원하는 웹 응용프로그램(Single Page Application)입니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.remoteseminar.com/ko/wp-content/uploads/sites/10/2019/09/img-role-01.png&#34; alt=&#34;https://www.remoteseminar.com/ko/wp-content/uploads/sites/10/2019/09/img-role-01.png&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;taashttpswwwtaasmobilecomko&#34;&gt;🔗&lt;a href=&#34;https://www.taasmobile.com/ko/&#34;&gt;TAAS&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;알서포트 (2016.4 - 2019.3)- fullStack&lt;/p&gt;
&lt;p&gt;서비스 아키텍쳐, Studio-ide 개발, product co-maintainer&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Electron, React, Redux, Nodejs, Appium, adb, shell, gitlab-ci, docker&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.taasmobile.com/en/wp-content/uploads/sites/2/2018/07/img_visual_main_flow01-1.png&#34; alt=&#34;https://www.taasmobile.com/en/wp-content/uploads/sites/2/2018/07/img_visual_main_flow01-1.png&#34;&gt;&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/WMfr3y8sRXc&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;hr&gt;
&lt;h2 id=&#34;gitlab-서버-운영&#34;&gt;Gitlab 서버 운영&lt;/h2&gt;
&lt;p&gt;알서포트 (2015.8 - 2019.3) - 서버 설치/관리/운영&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;사내 소스 코드 버전 관리 시스템을 Git으로 전환하자는 의견, 제안을 꾸준히 하였고 Gitlab-CE 버전을 사내에 직접 설치/운영/교육 하여 git 사용을 전파 함.&lt;/p&gt;
&lt;p&gt;2019년 3월 해당 업무 종료 - 사내 인프라 팀에서 자체 관리 / 업무 이관&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;html5-live-streaming-poc&#34;&gt;HTML5 Live Streaming (POC)&lt;/h2&gt;
&lt;p&gt;알서포트 (2015.12 - 2016.3) - frontend&lt;/p&gt;
&lt;p&gt;Mpeg-Dash, HLS, WebRTC, RTSP, Electron, Javascript&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;브라우저에서 플러그인 없이 동영상 방식의 PC 원격 제어가 가능한 통신 방법을 연구.&lt;/p&gt;
&lt;p&gt;여러 방식의 Live Streaming 적용, 품질 측정&lt;/p&gt;
&lt;p&gt;검증을 위한 코드 마이그레이션 / 데모 어플리케에션 작성 최종적으로 WebRTC 방식 제안.&lt;/p&gt;
&lt;p&gt;자사 제품에 도입 (도입 프로젝트 참여 안함)&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;pc-web-viewer-엔진-개발-poc&#34;&gt;PC Web-Viewer 엔진 개발 (POC)&lt;/h2&gt;
&lt;p&gt;알서포트 (2015.3 - 2015.9) - frontend&lt;/p&gt;
&lt;p&gt;WebSocket, WebWorker, Binary Encode/Decode With JavaScript, JPEG Decode, Canvas&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;플러그인 없이 브라우저에서 자사의 원격 제어 프로토콜을 이용하여 윈도우즈 PC의 원격 제어를 검증.&lt;/p&gt;
&lt;p&gt;모비즌(안드로이드 원격제어) 엔진을 고도화하여 PC 원격 제어 품질을 검증함.&lt;/p&gt;
&lt;p&gt;이후 자사 제품에 브라우저 웹 클라이언트 방식 채택 및 도입 (도입 프로젝트 참여 안함)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lovejaco.github.io/images/project/login.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lovejaco.github.io/images/project/connecting.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lovejaco.github.io/images/project/windows.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;mobizenhttpswwwmobizencomlocaleko-웹-클라이언트&#34;&gt;🔗&lt;a href=&#34;https://www.mobizen.com/?locale=ko&#34;&gt;Mobizen&lt;/a&gt; 웹 클라이언트&lt;/h2&gt;
&lt;p&gt;알서포트 (2014.2 - 2015.2)- frontend&lt;/p&gt;
&lt;p&gt;Websocket, IndexedDB, Binary Encode/Decode With JavaScript&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;브라우저에서 별도의 플러그인 없이 안드로이드 모바일 디바이스를 원격 제어하고, 디바이스의 미디어에 액세스 가능한 웹 클라이언트 개발 (개발 후반에 참여)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;웹 소켓을 이용한 자사 바이너리 프로토콜 encode/decode 엔진의 고도화 (성능 개선)&lt;/li&gt;
&lt;li&gt;디바이스 미디어 데이터의 관리(조회, 저장, 삭제) 기능 구현 (indexedDB)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://lovejaco.github.io/images/project/1.PNG&#34; alt=&#34;https://support-mirroring.mobizen.com/hc/article_attachments/115010319927/1.PNG&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;neos-work-system-고도화-프로젝트&#34;&gt;NeOS Work System 고도화 프로젝트&lt;/h2&gt;
&lt;p&gt;프리랜서 (2013.10 - 2014.1)&lt;/p&gt;
&lt;p&gt;Silverlight5, WPF, C#, SQL&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;neOS(NETWORK O&amp;amp;S)
Access, SO, 전송/전력, 관제 기반한 업무 지원 System으로 Site Schedule, 시설물 안전점검, 현장 출동 요청(고장), 관리 등의 시스템 고도화 프로젝트 개발 참여&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;포스코건설-pi-개발-프레임워크-지원&#34;&gt;포스코건설 PI 개발 프레임워크 지원&lt;/h2&gt;
&lt;p&gt;프리랜서 (2013.8 - 2013.9) - 프레임워크 운영&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;PI 2기 개발 웹 프레임워크 운영/지원/개발자 교육&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;velox&#34;&gt;Velox&lt;/h2&gt;
&lt;p&gt;스파크앤어소시에이츠 (2012.5 - 2013.4) - backend&lt;/p&gt;
&lt;p&gt;OpenStack(Swift, Swift-Keystone), Nginx, Node.js, MongoDB, Redis&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;OpenStack 인프라를 이용하여 드롭박스와 같은 서비스를 구축하는 프로젝트로, OpenStack 인프라를 널리 소개하려는 목적을 가진 프로젝트에서 백엔드 개발 담당&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lovejaco.github.io/images/project/943976.png&#34; alt=&#34;https://firejune.com/attach/1126/121126200035496502/943976.png&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;dk-온라인-게임-사이트-개발&#34;&gt;DK 온라인 게임 사이트 개발&lt;/h2&gt;
&lt;p&gt;스마일게이트 인터넷 (2011.9 - 2012.5) - backend&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://asp.net/&#34;&gt;ASP.NET&lt;/a&gt; MVC3, MS-SQL, C#&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;온라인 게임 사이트 개발 Backend 파트 리드 개발&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lovejaco.github.io/images/project/file_visual_20140617145846.jpg&#34; alt=&#34;http://www.smilegate.com/uploadfile/game/3/file_visual_20140617145846.jpg&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;리모트뷰-엔터프라이즈&#34;&gt;리모트뷰 엔터프라이즈&lt;/h2&gt;
&lt;p&gt;알서포트 (2010.3 - 2011.5) - backend&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://asp.net/&#34;&gt;ASP.NET&lt;/a&gt; MVC2, MS-SQL, C#&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;기업용 원격제어 솔루션 리모트뷰 - 엔터프라이즈 솔루션 웹 백엔드 리드 개발&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lovejaco.github.io/images/project/remoteview-2.jpg&#34; alt=&#34;http://www.bloter.net/files/2011/05/remoteview-2.jpg&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;포스코건설-인사노무-시스템-개발운영&#34;&gt;포스코건설 인사/노무 시스템 개발/운영&lt;/h2&gt;
&lt;p&gt;프리랜서(2007.5 - 2009.8)&lt;/p&gt;
&lt;p&gt;C# SmartClient, Winform, WCF, SOAP, MS-SQL&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;PMS,인사 시스템개발&lt;/p&gt;
&lt;p&gt;연차, 급여/상여, 연말정산 시스템 운영&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;crm-솔루션&#34;&gt;CRM 솔루션&lt;/h2&gt;
&lt;p&gt;(2006.1 - 2007.4) - backend&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://asp.net/&#34;&gt;ASP.NET&lt;/a&gt;, MS-SQL&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;전화 발신장치(CID)연동 주문 CRM 솔루션 개발&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;모바일-컨텐츠-서버-개발&#34;&gt;모바일 컨텐츠 서버 개발&lt;/h2&gt;
&lt;p&gt;(2015.8 - 2016.1) - backend&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;모바일(WIPI) 컨텐츠 서버 개발&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>해시 함수, 암호화 해시 함수, 그리고 SHA</title>
      <link>https://lovejaco.github.io/posts/cryptographic-hash-function/</link>
      <pubDate>Wed, 27 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://lovejaco.github.io/posts/cryptographic-hash-function/</guid>
      <description>&lt;p&gt;이 게시물은 해시 함수와 암호화 해시 함수의 차이를 구분하고 대표적인 SHA 알고리즘의 사용 사례(best pratice)와 취약점에 대해 설명합니다. 이를 통해 안전한 패스워드의 저장 방법 또는 전송 계층 보안(TLS)으로 한걸음 다가가기 위한 사전 교육 단계의 목적을 가지고 있습니다.&lt;/p&gt;
&lt;p&gt;그런 다음 &lt;a href=&#34;https://d2.naver.com/helloworld/318732&#34;&gt;안전한 패스워드 저장 - NAVER D2&lt;/a&gt;, &lt;a href=&#34;https://brunch.co.kr/@mobiinside/1482&#34;&gt;버즈빌의 개발 이야기- 보안 프로토콜 TLS 1.3&lt;/a&gt;와 같은 게시물을 읽는 것을 추천합니다.&lt;/p&gt;
&lt;h2 id=&#34;해시-해시-함수&#34;&gt;해시, 해시 함수&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://lovejaco.github.io/images/cryptographic-hash-function/480px-Hash_table_4_1_1_0_0_1_0_LL.svg.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ko.wikipedia.org/wiki/%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98&#34;&gt;해시 함수&lt;/a&gt;는 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수이며 체크섬, 핑거프린트, 손실 압축, 확률화 함수, 오류 수정 코드, 암호 등의 개념과 어느 정도 중첩되지만 각각의 용도와 요구 사항이 다르게 설계되고 최적화됩니다. &lt;a href=&#34;https://ko.wikipedia.org/wiki/%ED%95%B4%EC%8B%9C&#34;&gt;해시(또는 해시값)&lt;/a&gt;은 해시 함수로 가공한 결과를 말하며 또한 해시 코드, 해시섬, 체크섬 등으로 불립니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;hello = a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;해시-테이블&#34;&gt;해시 테이블&lt;/h3&gt;
&lt;p&gt;해시가 사용되는 대표적인 사례는 해시 테이블입니다. 자바스크립트에서 &lt;a href=&#34;https://twitter.com/v8js/status/958046113390411776&#34;&gt;Map / Set / WeakSet / WeakMap은 모두 해시 테이블을 사용합니다. - V8 on Twitter&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lovejaco.github.io/images/cryptographic-hash-function/440px-Hash_table_3_1_1_0_1_0_0_SP.svg.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;해시 테이블&lt;/strong&gt;은 해시 함수를 사용하여 키를 해시값으로 매핑하고, 이 해시값을 색인(index) 혹은 주소 삼아 데이터의 값(value)을 키와 함께 저장하는 &lt;a href=&#34;https://ko.wikipedia.org/wiki/%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0&#34;&gt;자료 구조&lt;/a&gt;입니다.&lt;/p&gt;
&lt;p&gt;아직 사용 되지않은 공간을 마련해야 하는 단점이 있지만 값과 매핑된 해시를 이용하면 값을 매번 비교할 필요가 없어 빠릅니다.&lt;/p&gt;
&lt;h2 id=&#34;암호화-해시cryptographic-hash&#34;&gt;암호화 해시(Cryptographic Hash)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://lovejaco.github.io/images/cryptographic-hash-function/750px-Cryptographic_Hash_Function.svg.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ko.wikipedia.org/wiki/%EC%95%94%ED%98%B8%ED%99%94_%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98&#34;&gt;암호화 해시 함수&lt;/a&gt;는 &lt;a href=&#34;https://ko.wikipedia.org/wiki/%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98&#34;&gt;해시 함수&lt;/a&gt;의 일종으로, 암호화 해시 함수가 가져야 하는 성질은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;역상 저항성(preimage resistance)&lt;/strong&gt;: 주어진 해시에 대해 입력값을 찾는 것이 계산상 어렵다. 즉, &lt;a href=&#34;https://ko.wikipedia.org/wiki/%EC%97%AD%EC%83%81_%EA%B3%B5%EA%B2%A9&#34;&gt;제 1 역상 공격&lt;/a&gt; 에 대해 안전해야 한다. 이 성질은 &lt;a href=&#34;https://ko.wikipedia.org/wiki/%EC%9D%BC%EB%B0%A9%ED%96%A5%ED%95%A8%EC%88%98&#34;&gt;일방향함수&lt;/a&gt; 와 연관되어 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;제 2 역상 저항성(second preimage resistance)&lt;/strong&gt;: 입력 값에 대해, 그 입력의 해시 값을 바꾸지 않으면서 입력을 변경하는 것이 계산상 어렵다. &lt;a href=&#34;https://ko.wikipedia.org/wiki/%EC%97%AD%EC%83%81_%EA%B3%B5%EA%B2%A9&#34;&gt;제 2 역상 공격&lt;/a&gt; 에 대해 안전해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;충돌 저항성(collision resistance)&lt;/strong&gt;: &lt;a href=&#34;https://ko.wikipedia.org/wiki/%ED%95%B4%EC%8B%9C_%EC%B6%A9%EB%8F%8C&#34;&gt;해시 충돌&lt;/a&gt; 에 대해 안전해야 한다. 같은 해시 값을 생성하는 두 개의 입력값을 찾는 것이 계산상 어려워야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;제 1 역상 공격&lt;/strong&gt;(first preimage attack): 해시값이 주어져 있을 때, 그 해시값을 출력하는 입력값을 찾는다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;제 2 역상 공격&lt;/strong&gt;(second preimage attack): 입력값이 주어져 있을 때, 그 입력과 같은 해시값을 출력하는 다른 입력값을 찾는다. 즉, 제 2 역상 공격은 제 1 역상 공격에서 원본 메시지까지 주어져 있는 경우이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;해시 충돌&lt;/strong&gt;: 서로 다른 두 개의 입력값에 대해 동일한 출력값을 내는 상황을 의미한다. 해시 함수가 무한한 가짓수의 입력값을 받아 유한한 가짓수의 출력값을 생성하는 경우, &lt;a href=&#34;https://ko.wikipedia.org/wiki/%EB%B9%84%EB%91%98%EA%B8%B0%EC%A7%91_%EC%9B%90%EB%A6%AC&#34;&gt;비둘기집 원리&lt;/a&gt; 에 의해 해시 충돌은 항상 존재한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;따라서, 암호화 해시 함수의 특성은 다음과 같습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;동일한 입력값으로 항상 동일한 해시를 생성합니다.&lt;/li&gt;
&lt;li&gt;주어진 입력값에 대해 빠르게 해시 연산을 수행합니다.&lt;/li&gt;
&lt;li&gt;해시로부터 입력 값을 생성하는 것은 계산상 어렵습니다..&lt;/li&gt;
&lt;li&gt;동일한 해시를 가진 두 개의 서로 다른 메시지를 찾는 것은 계산상 어렵습니다.&lt;/li&gt;
&lt;li&gt;메시지를 아주 조금만 변경해도 해시가 광범위하게 변경되어 이전 해시와 관련성을 찾을 수 없습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;암호학cryptography-vs-암호화encryption&#34;&gt;암호학(Cryptography) vs 암호화(Encryption)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://ko.wikipedia.org/wiki/%EC%95%94%ED%98%B8%ED%95%99&#34;&gt;암호학&lt;/a&gt;은 안전한 통신을 제공하는데 사용되는 알고리즘, 수학, 정보 이론, 전송, 암호화 등의 다양한 기술(technologies)과 기법(techniques)을 포함하는 반면, &lt;a href=&#34;https://ko.wikipedia.org/wiki/%EC%95%94%ED%98%B8%ED%99%94&#34;&gt;암호화&lt;/a&gt;는 암호학의 기법중 하나로 메시지를 인코딩 하는 프로세스입니다.&lt;/p&gt;
&lt;p&gt;그러나 종종 이 둘을 모두 암호화로 혼동하여 부르는 경향이 있으며, 이로 인해 때때로 “암호화 해시(cryptography hash function)는 암호화(Encryption)가 아니다”라는 식의 논쟁을 유발하기도 합니다.&lt;/p&gt;
&lt;p&gt;해시를 생성하는 것을 암호화(Encryption)라고 부르지는 않지만 우리가 소프트웨어를 개발할 때 안전한(secure) 통신 목적을 달성하기 위해서는 다양한 &lt;a href=&#34;https://ko.wikipedia.org/wiki/%EC%95%94%ED%98%B8%ED%95%99&#34;&gt;암호학&lt;/a&gt; 기법을 동시에 사용하게 되며 이때 &lt;a href=&#34;https://ko.wikipedia.org/wiki/%EC%95%94%ED%98%B8%ED%99%94&#34;&gt;암호화&lt;/a&gt; 및 암호화 해시 함수등은 암호학의 구성요소가 됩니다.&lt;/p&gt;
&lt;h2 id=&#34;what-is-sha&#34;&gt;What is SHA&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://ko.wikipedia.org/wiki/SHA&#34;&gt;SHA(Secure Hash Algorithm)&lt;/a&gt;는 가장 널리 사용되는 함호화 해시 중 하나로, 1993년 &lt;a href=&#34;https://ko.wikipedia.org/wiki/%EB%AF%B8%EA%B5%AD_%EA%B5%AD%EA%B0%80%EC%95%88%EB%B3%B4%EA%B5%AD&#34;&gt;미국 국가안보국&lt;/a&gt; (NSA)에 의해 설계 되었으며 미국 연방 정보 처리 표준입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SHA 함수군에 속하는 최초의 함수는 공식적으로 &lt;strong&gt;SHA&lt;/strong&gt;라고 불리지만, 나중에 설계된 함수들과 구별하기 위하여 &lt;strong&gt;SHA-0&lt;/strong&gt;이라고도 불린다. 2년 후 SHA-0의 변형인 &lt;strong&gt;SHA-1&lt;/strong&gt;이 발표되었으며, 그 후에 4종류의 변형, 즉 &lt;strong&gt;SHA-224&lt;/strong&gt;, &lt;strong&gt;SHA-256&lt;/strong&gt;, &lt;strong&gt;SHA-384&lt;/strong&gt;, &lt;strong&gt;SHA-512&lt;/strong&gt;가 더 발표되었다. 이들을 통칭해서 &lt;strong&gt;SHA-2&lt;/strong&gt;라고 하기도 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;sha-알고리즘의-사용-사례&#34;&gt;SHA 알고리즘의 사용 사례&lt;/h2&gt;
&lt;h3 id=&#34;파일-식별&#34;&gt;파일 식별&lt;/h3&gt;
&lt;p&gt;전체 파일을 전달하는 해시 함수를 실행하면 항상 동일한 출력이 생성됩니다. 이것은 &lt;strong&gt;소프트웨어를 배포할 때&lt;/strong&gt; 특히 유용합니다. 예를 들어 Linux 배포판을 다운로드하려는 경우 &lt;strong&gt;체크섬(checksum)&lt;/strong&gt; 파일을 가져와서 다운로드 중에 파일이 변경되었거나 손상되었는지 확인할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;git&#34;&gt;Git&lt;/h3&gt;
&lt;p&gt;Git에서는 변경 내역(커밋)의 해시(SHA1)를 생성하여, 데이터를 관리합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;commit 4bb84d634098d152d478b2959fc2f2c4fc44e0d9&lt;br&gt;
Merge: 500edefa dcbe9b19&lt;br&gt;
Author: Sung Yeol Yim&lt;br&gt;
Date: Mon May 25 08:36:10 2020 +0000&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/811068/&#34;&gt;Git의 차기 해시 알고리즘&lt;/a&gt;으로 SHA 256을 채택하고 적용하려는 시도가 있으며 천천히 실현되고 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;파티셔닝-데이터&#34;&gt;파티셔닝 데이터&lt;/h3&gt;
&lt;p&gt;해시를 사용하여 데이터가 저장된 위치를 식별하면 해시 파티션이 생깁니다. 이 개념은 상당히 복잡하며 &lt;strong&gt;데이터베이스&lt;/strong&gt;와 같이 훨씬 더 복잡한 솔루션에서 사용됩니다. 좋은 예는 &lt;a href=&#34;http://openstack.org/projects/storage/&#34;&gt;OpenStack Object Storage-Swift&lt;/a&gt; 입니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://julien.danjou.info/content/images/2018/03/openstack-swift-storage-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;블록-체인&#34;&gt;블록 체인&lt;/h3&gt;
&lt;p&gt;블록체인의 각 블록에는 해시 데이터가 포함됩니다. 이전 블록의 해시 값은 현재 블록의 해시 값을 계산하는 데 사용됩니다.
&lt;img src=&#34;https://lovejaco.github.io/images/cryptographic-hash-function/blockchain_to_calculate_2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://wiki.hash.kr/index.php/%EC%9D%B4%EC%A0%84%EB%B8%94%EB%A1%9D%ED%95%B4%EC%8B%9C&#34;&gt;이전블록해시&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://homoefficio.github.io/2016/01/23/BlockChain-%EA%B8%B0%EC%B4%88-%EA%B0%9C%EB%85%90/&#34;&gt;블록체인 기초 개념&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://m.blog.naver.com/PostView.nhn?blogId=shakey7&amp;amp;logNo=221576691305&amp;amp;proxyReferer=https:%2F%2Fwww.google.com%2F&#34;&gt;블록체인 기술적 구성 및 원리&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;암호화폐-bitcoin&#34;&gt;암호화폐 (Bitcoin)&lt;/h3&gt;
&lt;p&gt;블록체인과 비트 코인은 같은 것이 아닙니다. 차이점에 대해 알고 싶다면 &lt;a href=&#34;https://www.bloomberg.com/quicktake/bitcoins&#34;&gt;Bitcoin and Blockchain - Bloomberg&lt;/a&gt; 게시물을 확인하세요.&lt;br&gt;
비트코인에서 SHA-256은 어떻게 동작할까요?&lt;/p&gt;
&lt;p&gt;[&lt;strong&gt;채굴&lt;/strong&gt;]
SHA-256은 채굴자가 이전 블록 해시 매개 변수를 알아내기 위해 필요합니다. 그렇게 하려면 채굴자는 다음 공식을 따라야 합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이전 블록 해시 = SHA-256 (SHA-256 (블록 헤더))&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[&lt;strong&gt;비트코인 주소 생성&lt;/strong&gt;]
비트 코인 주소의 핵심은 공개 키입니다. 공개 키는 RIPEMD160과 SHA-256에 의해 해시 됩니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A = RIPEMD160 (SHA-256 (K))&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;hmac-해시-기반-메시지-인증-코드&#34;&gt;HMAC (해시 기반 메시지 인증 코드)&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://ko.wikipedia.org/wiki/%EB%A9%94%EC%8B%9C%EC%A7%80_%EC%9D%B8%EC%A6%9D_%EC%BD%94%EB%93%9C&#34;&gt;메시지 인증 코드(MAC)&lt;/a&gt;는 메시지 인증에 쓰이는 작은 크기의 정보로, 송신자와 수신자가 사전에 공유한 비밀키를 이용하여 메시지의 데이터를 인증하고 더불어 무결성을 보호합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lovejaco.github.io/images/cryptographic-hash-function/1322px-MAC.svg.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;MAC에 사용되는 Key에 따라 GMAC, HMAC, NMAC, CMAC, UMAC, VMAC 등으로 구분되며, &lt;a href=&#34;https://en.wikipedia.org/wiki/HMAC&#34;&gt;HMAC&lt;/a&gt;은 SHA-1, SHA-256등의 해시를 이용합니다.&lt;/p&gt;
&lt;h3 id=&#34;sslsecure-sockets-layer-인증서&#34;&gt;SSL(Secure Sockets Layer) 인증서&lt;/h3&gt;
&lt;p&gt;웹 사이트 및 웹 서비스의 보안은 인증서 파일을 기반으로 하며, 보안 연결을 설정하고 인증하는데 사용됩니다. 이 인증서에는 SHA-256과 같은 알고리즘을 사용하여 생성된 암호화 요소가 포함되어 있습니다.&lt;/p&gt;
&lt;p&gt;2011년부터 2015년 까지는 기본 알고리즘이 SHA-1이었지만, 취약점이 발견되어 2016년 12월 31일부터 웹 사이트의 서명 해시 알고리즘은 SHA-256이 산업 표준이 되었습니다.&lt;/p&gt;
&lt;h3 id=&#34;패스워드-저장&#34;&gt;패스워드 저장&lt;/h3&gt;
&lt;p&gt;생성된 해시로부터 원래의 입력값을 알아내지 못하는 단방향 해시의 특성을 이용하여 패스워드 데이터의 유출로 인한 2차 피해를 방지(원본 패스워드를 알아내지 못하도록) 하기 위해 SHA 알고리즘을 이용하여 해시를 생성하고 이를 저장합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SHA 취약점에 따라 한국인터넷진흥원(KISA)에는 SHA-256 이상의 알고리즘을 사용할 것을 권고 하고 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;sha-취약점-및-주의-사항&#34;&gt;SHA 취약점 및 주의 사항&lt;/h2&gt;
&lt;h3 id=&#34;sha1-취약점&#34;&gt;SHA1 취약점&lt;/h3&gt;
&lt;p&gt;2013년까지 발행된 디지털 인증서의 98%는 전적으로 SHA-1에 의존했습니다. 2017년에 크롬 브라우저는 SHA-1 인증서가 적용된 사이트 접속 시 페이지 표시를 거부 하였습니다. 그러나 실제로는 &lt;a href=&#34;https://security.googleblog.com/2014/09/gradually-sunsetting-sha-1.html&#34;&gt;단계적으로 SHA-1 사용을 줄여감으로써 결국 단종시키겠다고 선언&lt;/a&gt; 함으로서 프로세스는 시작되었습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lovejaco.github.io/images/cryptographic-hash-function/image_1-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zdnet.co.kr/view/?no=20170224153403&#34;&gt;구글, 구형 암호기술 ‘SHA1’ 허점 입증했다&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.boannews.com/media/view.asp?idx=48181&#34;&gt;각종 인증서 기본이 되는 SHA-1에 충돌 공격 비상&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;마이크로소프트 역시 &lt;a href=&#34;https://support.microsoft.com/ko-kr/help/3123479/microsoft-security-advisory-deprecation-of-sha-1-hashing-algorithm-for&#34;&gt;루트 인증서 프로그램의 SHA-1 해시 알고리즘 사용 중단 -2016/1/12&lt;/a&gt; 및&lt;br&gt;
&lt;a href=&#34;https://support.microsoft.com/ko-kr/help/4472027/2019-sha-2-code-signing-support-requirement-for-windows-and-wsus&#34;&gt;SHA-2 코드 서명 지원 요구 사항&lt;/a&gt;을 통해 윈도우즈 업데이트에서 SHA-1사용을 제거하였습니다.
이와 관련하여 저의 게시물 &lt;a href=&#34;https://lovejaco.github.io/posts/microsoft-is-abandoning-sha-1-hashes-for-updates/&#34;&gt;번역 - 마이크로소프트가 SHA-1 업데이트를 포기한 이유?&lt;/a&gt;를 읽어 보는 것도 흥미로울 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;sha2-취약점&#34;&gt;SHA2 취약점&lt;/h3&gt;
&lt;p&gt;SHA-2에 대한 공격은 아직 발견되지 않았고, 안전하다고 알려져 있으나, SHA-1과 비슷한 방법을 사용하기 때문에 공격이 발견될 가능성이 있다고 지적합니다. &lt;a href=&#34;https://ko.wikipedia.org/wiki/%EB%AF%B8%EA%B5%AD_%ED%91%9C%EC%A4%80_%EA%B8%B0%EC%88%A0_%EC%97%B0%EA%B5%AC%EC%86%8C&#34;&gt;미국 표준 기술 연구소&lt;/a&gt; (NIST)는 &lt;a href=&#34;https://ko.wikipedia.org/wiki/SHA-3&#34;&gt;SHA-3&lt;/a&gt;로 불리는 새로운 암호화 해시 알고리즘에 대한 후보를 공모하였습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.itworld.co.kr/news/108321&#34;&gt;왜 SHA-3을 사용하지 않는가 - ITWorld Korea&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://seed.kisa.or.kr/kisa/bbs/faq.do&#34;&gt;한국인터넷진흥원 권고 암호화 알고리즘&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;공공기관과 민간 기관의 권고 사양이 달라 때때로 혼란을 유발함.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;패스워드-해시-알고리즘&#34;&gt;패스워드 해시 알고리즘&lt;/h3&gt;
&lt;p&gt;패스워드를 저장하는 목적으로 SHA-2를 사용하는 것은 과연 안전할까요?&lt;/p&gt;
&lt;h4 id=&#34;무차별-대입공격brute-force-attack&#34;&gt;무차별 대입공격(brute-force attack)&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://ko.wikipedia.org/wiki/%EB%AC%B4%EC%B0%A8%EB%B3%84_%EB%8C%80%EC%9E%85_%EA%B3%B5%EA%B2%A9&#34;&gt;무차별 대입 공격&lt;/a&gt;은 가능한 모든 입력값을 대입하여 암호를 풀어내는 공격 방법으로, 대부분의 암호화 방식은 이론적으로 무차별 대입 공격에 대해 안전하지 못하며, 충분한 시간이 존재한다면 암호화된 정보를 해독할 수 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://youtu.be/nvzMN5Z8DJI?t=1542&#34;&gt;GOTO 2019 • AppSec: From the OWASP Top Ten(s) to the OWASP ASVS • Jim Manico - YouTube&lt;/a&gt; 이 영상에서 GPU를 사용하는 고성능 머신으로 1초에 무려 950억 개의 SHA-256 해시 계산이 가능했다고 말합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;저는 위 영상을 보고 &lt;a href=&#34;https://aws.amazon.com/ko/blogs/korea/new-p2-instance-type-for-amazon-ec2-up-to-16-gpus/&#34;&gt;Amazon EC2 P2&lt;/a&gt; 인스턴스에서 &lt;a href=&#34;https://hashcat.net/hashcat/&#34;&gt;hashcat&lt;/a&gt;을 이용하여 패스워드 무차별 대입 공격 데모를 작성하였습니다. 이때 1초에 1억 개 이상의 해시를 생성하였으며 salt 가 포함되지 않은 SHA-256으로부터 생성된 해시를 비교하여 8자리의 패스워드를 단 1초 만에 알아낼 수 있었습니다.&lt;/p&gt;
&lt;h4 id=&#34;dictionary-attack-사전-공격&#34;&gt;Dictionary Attack (사전 공격)&lt;/h4&gt;
&lt;p&gt;원본( &lt;a href=&#34;http://www.ktword.co.kr/abbr_view.php?nav=&amp;amp;m_temp1=4240&amp;amp;id=532&#34;&gt;평문&lt;/a&gt; )에 대해 미리 계산된 &lt;a href=&#34;http://www.ktword.co.kr/abbr_view.php?nav=&amp;amp;m_temp1=1211&amp;amp;id=960&#34;&gt;해쉬값&lt;/a&gt; 들을 모아서 사전 형태로 만들어놓고 대입해보는 공격 방법입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(유사) 미리 계산해둔 테이블을 레인보우 테이블 (Rainbow Table)이라고 합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://md5decrypt.net/en/Sha256/&#34;&gt;Sha256 Decrypt &amp;amp; Encrypt - More than 15.000.000.000 hashes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.dcode.fr/sha256-hash&#34;&gt;SHA-256 - Password SHA256 Hash Decryption - Online Decoder/Encoder&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://md5hashing.net/hash/sha256&#34;&gt;Ultimate Hashing and Anonymity toolkit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위와 같은 사이트에서 미리 수집한 해시 값을 이용하여 원본 데이터를 유추할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;요약&#34;&gt;요약&lt;/h2&gt;
&lt;p&gt;성공적인 정보 보안 체계로 이끄는 주요 목표는 기밀성(Confidentiality), 무결성(Integrity), 인증성(Authentication), 사용성(Availability) 그리고 부인방지(non-repudiation)입니다.&lt;/p&gt;
&lt;p&gt;암호화 해시를 이해하는 것은 다음의 주제로 나아가는데 도움이 됩니다.&lt;/p&gt;
&lt;p&gt;SHA-2와 같은 암호화 해시는 각각의 목표에 따라 상호 보완적으로 다양하게 사용되고 있으며, 빠른 계산 성능으로 인해 패스워드와 같은 민감한 데이터를 저장하는 것은 주의해야 하며, SHA 알고리즘 보다 느리게 수행되는 알고리즘이 선호 됩니다.&lt;/p&gt;
&lt;p&gt;[참고 문헌]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cheatsheetseries.owasp.org/&#34;&gt;Introduction · OWASP Cheat Sheet Series&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://assets.cdngetgo.com/1d/ee/d051d8f743b08f83ee8f3449c15d/lastpass-technical-whitepaper.pdf&#34;&gt;Summary of Key LastPass Security Principles - Whitepaper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.binance.vision/security/what-is-hashing&#34;&gt;What Is Hashing? | Binance Academy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.joinc.co.kr/w/man/12/hmac&#34;&gt;HMAC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://julien.danjou.info/openstack-swift-consistency-analysis/&#34;&gt;OpenStack Swift eventual consistency analysis &amp;amp; bottlenecks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.mycryptopedia.com/sha-256-related-bitcoin/&#34;&gt;What Is SHA-256 And How Is It Related to Bitcoin? - Mycryptopedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.educba.com/cryptography-vs-encryption/&#34;&gt;Cryptography vs Encryption | 6 Awesome Differences You Should Learn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://news.samsung.com/kr/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EA%B8%B0%EC%88%A0%EC%9D%98-%ED%95%B5%E6%A0%B8-%EC%95%94%ED%98%B8-%ED%95%B4%EC%8B%9C&#34;&gt;블록체인 기술의 핵(核), ‘암호 해시’ 파헤치기 – Samsung Newsroom Korea&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://julien.danjou.info/openstack-swift-consistency-analysis/&#34;&gt;OpenStack Swift eventual consistency analysis &amp;amp; bottlenecks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ssl2buy.com/wiki/difference-between-hashing-and-encryption&#34;&gt;Difference Between Hashing and Encryption&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.howtogeek.com/238705/what-is-sha-1-and-why-will-retiring-it-kick-thousands-off-the-internet/&#34;&gt;SHA-1 Collision Attacks, Explained&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>vscode를 커맨드라인으로 실행할 때 Dock 아이콘이 중복으로 생성되는 문제 해결</title>
      <link>https://lovejaco.github.io/posts/vscode-command-line-generate-duplicate-icons-in-dock/</link>
      <pubDate>Mon, 13 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://lovejaco.github.io/posts/vscode-command-line-generate-duplicate-icons-in-dock/</guid>
      <description>&lt;p&gt;먼저, 이 증상은 macOS Mojave(그 이상)에서 나타나는 현상입니다.&lt;/p&gt;
&lt;h3 id=&#34;커맨드라인-명령으로-code-실행&#34;&gt;커맨드라인 명령으로 code 실행&lt;/h3&gt;
&lt;p&gt;쉘의 환경 설정에 path를 지정하고, 확인합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&amp;gt; nano ~/.zshrc
export PATH&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;/Applications/Visual&lt;span style=&#34;color:#ae81ff&#34;&gt;\\&lt;/span&gt; Studio&lt;span style=&#34;color:#ae81ff&#34;&gt;\\&lt;/span&gt; Code.app/Contents/Resources/app/bin:$PATH

&amp;gt; which code
/Applications/Visual&lt;span style=&#34;color:#ae81ff&#34;&gt;\ &lt;/span&gt;Studio&lt;span style=&#34;color:#ae81ff&#34;&gt;\ &lt;/span&gt;Code.app/Contents/Resources/app/bin/code

&amp;gt; code &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;경로&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;그런 다음, 커맨드 라인 명령으로 vscode를 실행할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;dock-아이콘-중복-생성&#34;&gt;dock 아이콘 중복 생성&lt;/h3&gt;
&lt;p&gt;code를 실행할 때마다 dock 아이콘이 중복해서 생성됩니다.
&lt;img src=&#34;https://lovejaco.github.io/images/screen-shot-2020-05-12.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;macos-mojave-code-command-line-generate-duplicate-icons-in-dock-60579&#34;&gt;macOS Mojave: code command line generate duplicate icons in dock #60579&lt;/h3&gt;
&lt;p&gt;vscode의 github 리파지토리에서 &lt;a href=&#34;https://github.com/microsoft/vscode/issues/60579&#34;&gt;관련 이슈&lt;/a&gt;를 발견 하였습니다. 그 중 제가 확인한 방법은 다음과 같습니다.&lt;/p&gt;
&lt;h4 id=&#34;1-시스템-설정-변경&#34;&gt;1. 시스템 설정 변경&lt;/h4&gt;
&lt;p&gt;최근 사용한 응용프로그램 보기 &lt;strong&gt;비 활성&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;System Preference &amp;gt; Dock &amp;gt; Show recent applications inDock&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.techjunkie.com/recent-applications-extra-icons-mojave-dock/&#34;&gt;링크(macOS Mojave: Turn Off Recent Applications to Remove Extra Dock Icons)&lt;/a&gt;를 참조하여 최근 사용한 애플리케이션 항목을 비 활성할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/900690/69153851-3d42e380-0adf-11ea-88a2-b063875e5124.gif&#34; alt=&#34;https://user-images.githubusercontent.com/900690/69153851-3d42e380-0adf-11ea-88a2-b063875e5124.gif&#34;&gt;&lt;/p&gt;
&lt;p&gt;이 방법을 적용하면, 아이콘이 나타났다가 사라지는 애니메이션 때문에 어딘가 좀 어색합니다. 그리고 개인적으로 시스템 설정을 변경하는 것을 원하지 않았습니다.&lt;/p&gt;
&lt;h4 id=&#34;2-define-shell-function&#34;&gt;2. Define Shell function&lt;/h4&gt;
&lt;p&gt;.bashrc 또는 .zshrc 같은 shell의 환결 설정에 함수를 지정하는 방법이 있습니다.
저는 다음의 조치를 따랐습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&amp;gt; nano ~/.zshrc
code&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt; -t &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt; -t &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;then&lt;/span&gt;
        open -a Visual&lt;span style=&#34;color:#ae81ff&#34;&gt;\\&lt;/span&gt; Studio&lt;span style=&#34;color:#ae81ff&#34;&gt;\\&lt;/span&gt; Code.app &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$@&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
        open -a Visual&lt;span style=&#34;color:#ae81ff&#34;&gt;\\&lt;/span&gt; Studio&lt;span style=&#34;color:#ae81ff&#34;&gt;\\&lt;/span&gt; Code.app -f
    &lt;span style=&#34;color:#66d9ef&#34;&gt;fi&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;vscode를 모두 종료하고 터미널을 새로 열어 테스트 하니 잘 동작합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>http head of line blocking</title>
      <link>https://lovejaco.github.io/posts/head-of-line-blocking/</link>
      <pubDate>Mon, 06 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://lovejaco.github.io/posts/head-of-line-blocking/</guid>
      <description>&lt;p&gt;팀 스터디 발표 시간에 관련 이슈가 언급되어, 보충 설명을 위해 작성된 게시물입니다.
HTTP2, HTTP3을 이해하는데 약간의 도움이 될 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;htt-1x&#34;&gt;HTT 1.x&lt;/h2&gt;
&lt;p&gt;모두 알고 있듯, HTTP는 비 연결성 프로토콜입니다. 많은 수의 리소스 요청을 처리하기 위해서 다수의 커넥션을 사용합니다. 그리고 &lt;a href=&#34;https://docs.pushtechnology.com/cloud/latest/manual/html/designguide/solution/support/connection_limitations.html&#34;&gt;브라우저의 동시 연결 제한&lt;/a&gt; 때문에 &lt;a href=&#34;https://developer.mozilla.org/ko/docs/Web/HTTP/Connection_management_in_HTTP_1.x&#34;&gt;도메인 샤딩&lt;/a&gt;이라는 기법을 추가로 사용하여 리소스 연결 속도를 개선하고 있습니다.
그러나 이런 순차적인 연결은 &lt;strong&gt;HTTP Head of line blocking&lt;/strong&gt; 이슈를 유발합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;amp;fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F26040A41593815B020B6F5&#34; alt=&#34;이미지 출처: https://img1.daumcdn.net&#34;&gt;&lt;/p&gt;
&lt;p&gt;특정 요청의 응답에 지연이 발생하면 그 다음의 요청에도 영향을 받는다는 문제 입니다.&lt;/p&gt;
&lt;h2 id=&#34;http-2&#34;&gt;HTTP 2&lt;/h2&gt;
&lt;p&gt;구글의 SPDY에서 유래되어 HTTP2 표준으로 명명&lt;br&gt;
HTTP2는 다음의 방법으로 이 문제를 해결합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;영속적인 커넥션 사용&lt;/li&gt;
&lt;li&gt;멀티플렉싱 - 여러 개의 HTTP 요청/응답을 하나의 TCP 연결에서 보냄.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://t1.daumcdn.net/cfile/tistory/251B0644593A20A918&#34; alt=&#34;이미지 출처: https://t1.daumcdn.net/cfile/tistory/251B0644593A20A918&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;http-3&#34;&gt;HTTP 3&lt;/h2&gt;
&lt;p&gt;그러나 HTT2는 여전히 다른 종류의 어려움을 겪고 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://miro.medium.com/max/1400/1*9Y4-yxnqnhVZnnOIcuSohA.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;HTT2는 TCP를 사용하고 있기 때문에 만약 TCP 스트림에서 하나의 패킷이 손실된 경우 패킷이 재 전송 및 수신될 때까지 모든 스트림을 대기 시킵니다. 이를 &lt;strong&gt;TCP Head of line blocking&lt;/strong&gt;이라고 부릅니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lovejaco.github.io/images/quic-stack.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt;
&lt;p&gt;HTTP3는 UDP를 이용하여 이 문제를 해결하며, TCP와 유사하게 구현된 QUIC 프로토콜을 이용하여 패킷의 순서와 신뢰를 보장합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[번역] 더 좋은 코드 리뷰 방법: Part One</title>
      <link>https://lovejaco.github.io/posts/better-code-review-part-one/</link>
      <pubDate>Mon, 21 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://lovejaco.github.io/posts/better-code-review-part-one/</guid>
      <description>&lt;p&gt;원문 링크: &lt;a href=&#34;https://medium.com/retailmenot-engineering/better-code-review-part-one-ae3d4ff0494d&#34;&gt;Better Code Review: Part One – RetailMeNot Engineering – Medium&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;self-review&#34;&gt;Self-Review&lt;/h2&gt;
&lt;p&gt;코드 리뷰는 소프트웨어 엔지니어링에 필수적인 부분으로, 혼자 작업하지 않는 한 일상적인 소프트웨어 개발 업무의 한 부분이 될 가능성이 높습니다. 코드 리뷰는 때때로 논쟁을 유발하며, 그것은 치아 신경 치료만큼 재밌지만(?) 그럴 필요는 없습니다. 3부로 구성된 이 시리즈를 통해, 제 경험에서 얻은 몇 가지 팁을 제시하여 여러분의 코드가 좀 더 생산적이고 덜 부담스러운 방식으로 검토되고, 또 검토할 수 있도록 도울 것입니다. 첫째는, 자기-검토입니다. 다른 사람이 코드를 검토하기 전에 먼저 자기-검토 항목을 작성함으로써 버그를 조기에 발견하고, 보다 성공적인 기술 토론을 위해 준비할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://miro.medium.com/max/1400/1*V4A-q-EpHjv1_UGxYwKOgQ.jpeg&#34; alt=&#34;https://miro.medium.com/max/1400/1*V4A-q-EpHjv1_UGxYwKOgQ.jpeg&#34;&gt;&lt;/p&gt;
&lt;p&gt;2013년 Microsoft는 “왜 코드 리뷰를 해야 하고, 코드 리뷰를 통해 얻는 가장 빈번한 결과는 무엇이며, 효과적인 코드 리뷰 방법은 무엇인지” 알아내기 위한 &lt;a href=&#34;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/bosu2015useful.pdf&#34;&gt;내부 연구&lt;/a&gt;를 수행했습니다. 설문에 참여한 대부분의 사람들은 버그 발견을 코드 리뷰의 주요 동기로 응답했지만, 실제로 코드 결함을 보고한 응답은 14%에 불과하였습니다. 이 연구에서 밝혀진 코드 리뷰의 주요 성과는 지식 전파와 팀 의식 향상 그리고 문제에 대한 해결책 모색이었습니다. 이 정보를 바탕으로 위와 같은 성과를 이끌어 낼 수 있도록 검사자와 피검사자를 변화시킬 수 있는 방법은 무엇일까요?&lt;/p&gt;
&lt;p&gt;코드 리뷰 프로세스는 여러분이 pull request를 생성할 때 시작하는 것이 아니라, 공유 코드 베이스에 병합할 코드를 작성할 때 시작합니다. 관련 당사자들 모두에게 최선의 프로세스를 보장하기 위해 pull request를 생성 전에 수행해야 하는 몇 가지 의무 점검 사항이 있습니다. 저는 먼저 자기-검토를 수행함으로써 더 좋고 강력한 코드를 만들 수 있다고 믿고 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;three steps to self-review:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Run it&lt;/li&gt;
&lt;li&gt;Read it&lt;/li&gt;
&lt;li&gt;Document it&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;run-it&#34;&gt;Run it&lt;/h3&gt;
&lt;p&gt;뻔한 이야기로 들릴 수도 있지만, 코드를 실행해 보세요. 간단한 문자열 변경의 경우에도, 반드시 코드를 실행해 봐야 합니다. 검토가 필요한 코드가 동작하지 않으면 개발자와 QE(QA Engineer)의 시간이 낭비됩니다. 매우 똑똑한 개발자가 작성한 좋은 코드에서도 잘못 입력된 세미콜론이나, 뒤 바뀐 boolean 조건 때문에 충돌이 발생할 수 있습니다. PR을 생성하기 전에 항상 확인하는 것이 좋습니다. 하는 김에, Linter를 이용하는 것도 좋습니다. Annyce Davis가 작성한 셀프-리뷰를 자동화하기 위한 방법이라는 &lt;a href=&#34;http://adavis.info/2018/09/frustration-free-code-reviews.html&#34;&gt;아주 멋진 게시물&lt;/a&gt;을 읽어보세요. 검사자가 내용에 집중할 수 있도록 코드가 팀에서 합의한 스타일 가이드라인을 준수하는지 확인하세요. Microsoft의 연구에 따르면 코드 스타일에 대한 반복적인 언급이 기술적인 논의(토론)의 가치를 감소시키고 스트레스의 원인이 된다는것을 발견했습니다. 되도록 검사자 피검사자 모두 이를 준수해야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://miro.medium.com/max/926/0*xdXVYiTg6xNGNG77&#34; alt=&#34;https://cdn-images-1.medium.com/max/1600/0*xdXVYiTg6xNGNG77&#34;&gt;&lt;/p&gt;
&lt;p&gt;알아보기 어렵겠지만, if 문에서 실수로 변수 하나를 제거했더니 조건 문의 논리가 반대가 되었습니다. 단순히 코드를 읽는 것보다 코드를 실행해 보는 것이 쉽게 오류를 발견할 수 있는 방법 중 하나입니다.&lt;/p&gt;
&lt;h3 id=&#34;read-it&#34;&gt;Read it&lt;/h3&gt;
&lt;p&gt;PR 요청을 생성하기 전에 코드의 변경사항을 비교(diff) 한 후 개발과정에서 수행한 논리적 절차가 명확한지 스스로에게 질문해 보세요. 작성한 코드가 오직 일감에 관련된 문제만을 해결하고 있나요? 만약 변경 사항이 일감의 범위를 넘어서는 경우에는 해결해야 할 문제에 대해서만 초점을 유지하기 위해 개별 일감으로 분리하는 것이 좋습니다. 변수의 이름이 의미에 맞게 작성되었나요? yesOrNo라는 boolean 변수의 목적을 유추하기 어렵습니다. 피검사자로서 여러분의 역할은 코드 리뷰에 대한 기술 토론을 촉진시키기 충분한 컨텍스트를 제공해야 하는 것이므로, 코드에 얼마만큼을 추가하고 보완해야 할지 결정해야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://miro.medium.com/max/778/0*43sVISCL17QCZ_Yr&#34; alt=&#34;https://cdn-images-1.medium.com/max/1600/0*43sVISCL17QCZ_Yr&#34;&gt;&lt;/p&gt;
&lt;p&gt;위의 “inputSteam”과 같은 오타는 지적하기 번거로운(귀찮은) 부분이 있습니다.
비교(diff)를 통해 자신만의 문제를 찾고 수정하는 것이 가장 좋습니다.&lt;/p&gt;
&lt;h3 id=&#34;document-it&#34;&gt;Document it&lt;/h3&gt;
&lt;p&gt;진정한 자체-문서화 코드는 극히 드문 경우입니다. 대부분의 코드에는 여러 가지 형태의 별도의 문서가 존재합니다. 커밋 메시지처럼 간단할 수도 있고 (일감 번호가 표기되어 있지 않을 수도 있고) 혹은 전체 javadoc
처럼 복잡할 수도 있습니다. 테스트 코드 역시 코드가 동작하는 방식과 사용 방법을 문서화할 수 있는 매우 좋은 방법입니다. 코드가 의도한 대로 성공하고 실패하는지 테스트하세요. PR 요청을 만들 때 검사자를 위한 컨텍스트 그리고 코드를 개발할 때의 의사 결정 과정을 설명하는 코멘트를 제공하세요. PR 요청을 생성할 때 검사자를 위해 여러분이 코드를 작성 시 의사 결정 과정을 설명하는 코멘트를 제공하세요. 아마도 언젠가는 다른 사람이 여러분의 코드를 유지 관리해야 합니다. 코드가 어떤 이유로 왜 이렇게 동작하는지 도움이 될 수 있도록 최신 문서를 작성해야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://miro.medium.com/max/1180/0*REj9jO_woiXtWZcI&#34; alt=&#34;https://cdn-images-1.medium.com/max/1600/0*REj9jO_woiXtWZcI&#34;&gt;&lt;/p&gt;
&lt;p&gt;위의 반복적인 코드에서, 몇 줄의 명확한 설명의 주석이 가독성을 높입니다.&lt;/p&gt;
&lt;p&gt;코드를 실행하고, 읽고, 문서화하는 데 시간을 투자하는 것은 코드 리뷰 프로세스에서 피검사자의 성실함 중
한 부분입니다. PR 요청 전에 작은 버그나 스타일 이슈를 미리 해결해 두면 검사자가 좀 더 심도 있는 기술 토론에 집중할 수 있고, 논리적으로 명확하고 가독성 높은 코드를 통해 질문에 답하는 시간을 단축시킬 수 있습니다. 코드를 문서화하여 의사 결정 프로세스를 이해하고 향후 코드를 유지하는 데 필요한 컨텍스트를 제공하세요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[번역] 마이크로소프트가 SHA-1 업데이트를 포기한 이유?</title>
      <link>https://lovejaco.github.io/posts/microsoft-is-abandoning-sha-1-hashes-for-updates/</link>
      <pubDate>Sun, 20 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://lovejaco.github.io/posts/microsoft-is-abandoning-sha-1-hashes-for-updates/</guid>
      <description>&lt;p&gt;원문 링크: &lt;a href=&#34;https://www.cs.columbia.edu/~smb/blog/2019-02/2019-02-19.html&#34;&gt;SMBlog — 19 February 2019&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;마이크로소프트는 업데이트 프로세스에서 SHA-1 해시를 제거하기 위한 &lt;a href=&#34;https://arstechnica.com/gadgets/2019/02/mandatory-update-coming-to-windows-7-2008-to-kill-off-weak-update-hashes/&#34;&gt;패치를 준비 중입니다.&lt;/a&gt; SHA-1을 제거하는 것 자체는 아무런 문제가 없지만 그 이유는 매우 흥미로울 수 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[역자 주]&lt;br&gt;
취약한 SHA-1 알고리즘을 제거하기 위해 Windows 7, 2008에 필수 업데이트가 제공됨&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SHA-1은 &lt;a href=&#34;https://ko.wikipedia.org/wiki/%EC%95%94%ED%98%B8%ED%99%94_%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98&#34;&gt;암호학적 해시 함수&lt;/a&gt;입니다. 즉, 사이즈의 제한 없이 파일을 입력받아 20 바이트를 출력합니다. 암호학적 해시 함수의 본질적인 속성은 (이론적으로 분명하지는 않지만) 파일이 동일하지 않으면 동일한 해시값을 가지면 안 된다는 것입니다.&lt;/p&gt;
&lt;p&gt;SHA-1은 더 이상 그 속성을 가지고 있지 않습니다. 우리는 그것을 약 15년 동안 알고 있었습니다. 하지만 문제점을 정의하는 것은 중요합니다. SHA-1은 &lt;a href=&#34;https://ko.wikipedia.org/wiki/%EC%B6%A9%EB%8F%8C_%EA%B3%B5%EA%B2%A9&#34;&gt;충돌 공격&lt;/a&gt;에 취약합니다. 공격자는 동일한 SHA-1 해시값을 갖는 (즉 충돌이 발생하는) 두 개의 파일을 동시에 만들어낼 수 있습니다. 그러나 기존 파일과 그 해시를 알고 있다 해서 동일한 해시값을 갖는 두 번째 파일을 생성하는 것은 불가능하다고 모두가 알고 있습니다.이 공격을 &lt;a href=&#34;https://ko.wikipedia.org/wiki/%EC%97%AD%EC%83%81_%EA%B3%B5%EA%B2%A9&#34;&gt;역상 공격&lt;/a&gt;이라 부르며, 훨씬 더 심각한 (세 번째 유형의 공격, “제 2 역상 공격”은 생략합니다.)&lt;/p&gt;
&lt;p&gt;일반적인 이벤트 순서에 따라 마이크로소프트의 누군가가 업데이트 파일을 준비합니다. 이때 디지털 서명 알고리즘으로 SHA-1이 흔하게 사용됩니다. 만약 누군가 가짜 업데이트를 만들려는 사람이 있다면 서명 알고리즘을 깨뜨리거나, 합법적인 업데이트와 동일한 해시값을 갖는 가짜 업데이트 파일을 만들어내야 합니다. 하지만 이는 &lt;a href=&#34;https://ko.wikipedia.org/wiki/%EC%97%AD%EC%83%81_%EA%B3%B5%EA%B2%A9&#34;&gt;역상 공격&lt;/a&gt;이며, SHA-1은 여전히 이 공격에 대해 안전하다고 여겨집니다. 그렇다면 이 가짜 업데이트는 쓸모없는 시도 였을까요? 아니요, 완전히 그렇지는 않습니다. 여전히 위험합니다.&lt;/p&gt;
&lt;p&gt;SHA-1은 충돌 공격에 취약합니다. 즉, 두 개의 업데이트가 동시에 준비된 경우 하나는 문제없지만 다른 하나는 악의적인 업데이트가 될 수 있습니다. 다시 말해 여기서 위협 모델은 부패한 내부자입니다. 마이크로소프트는 SHA-1을 사용하지 않음으로써 직원의 잘못된 행동으로부터 고객을 보호합니다.&lt;/p&gt;
&lt;p&gt;어쩌면, 이것은 아마도 단순한 집안 문제로, 마이크로소프트가 코드 베이스에서 SHA-1 사용을 제거 함으로서 사용을 막을 수 있습니다. 이 알고리즘은 25년이나 되었으며 심각한 약점으로 가지고 있고, 이미 SHA-1을 사용하는 시절은 지났습니다. 그러나 다크 사이드로 눈을 돌리는 내부자가 매우 위험할 수 있다는 것을 인식해야 합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이 글을 작성한 시점으로부터 몇 개월 전 회사에서 업데이트 인증서 SHA-1 알고리즘 충돌 공격으로 인한 피해가 있었고 이를 이해하는데 이 글이 도움이 되었습니다. - 단 이는 원격 해킹으로 인한 피해 였음&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>[번역] 코드 리뷰 하는 이유</title>
      <link>https://lovejaco.github.io/posts/why-review-code/</link>
      <pubDate>Wed, 16 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://lovejaco.github.io/posts/why-review-code/</guid>
      <description>&lt;p&gt;원문 링크: &lt;a href=&#34;https://sophiebits.com/2018/12/25/why-review-code.html&#34;&gt;Why review code? – Sophie Alpert&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;최근 한 친구가 코드 리뷰를 하는 것이 왜 중요한지 저에게 물어보았습니다. 대부분의 실리콘 밸리 회사들은 모든 변경 사항에 대한 코드 리뷰를 수행하기 위해 최소한 두 명 이상을 편성합니다. 이전 회사 중 한 곳에서는 사전-동의 (opt-in) 코드 리뷰를 (드물게) 수행하였지만, 구글에서 새로 온 직원이 우리와 합류하여 모든 코드를 검토하도록 권장하였습니다. 그것은 정말 위대한 결정이었습니다.&lt;/p&gt;
&lt;p&gt;여러분이 만약 코드 리뷰를 제대로 한다면, 코드 리뷰가 부담스러워서는 안됩니다. 여러분과 여러분의 리뷰어는 적대자가 아닙니다. 최고의 소프트웨어를 구축하기 위해 함께 노력하고 있습니다. (개인적인 피드백(지적사항[역자-주])이 없도록 하는 것이 중요합니다. - 비록 코드를 변경해야 할 필요가 있다 하더라도, 그 자체가 문제는 아닙니다. 피드백을 받는 것이 일반적이며 성장에 도움이 됩니다.)&lt;/p&gt;
&lt;p&gt;일부 회사는 각 코드에 대한 책임을 지는 엄격한 “담당자(Owner)”와 함께 얼마나 많은 사람들이 해당 코드를 검토해야 하는지에 대한 복잡한 규칙을 가지고 있습니다. 저는 그것이 필요하다고 느껴본 적이 없습니다. 반드시 한 사람만이 코드를 검토해야 한다는 유일한 규칙의 간단한 시스템을 선호합니다. 실제로, 당신이 변경한 특정 코드를 유지 관리하는 담당자에게 계속 검토 요청을 보내고 있다면, 되도록 어려운 요구 사항을 포함하지 않는 것이 좋습니다.&lt;/p&gt;
&lt;p&gt;다음은 제가 코드 리뷰가 중요하다고 생각하는 가장 큰 이유입니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;The code itself.&lt;/strong&gt; 코드 리뷰의 가장 분명한 가치는 “버그 잡기”입니다. 조금 더 멀리 내다보면, 작성자가 미처 알지 못했던 “모범 사례(best practices)”또는 무언의 규칙을 포착하고 실제 구현 코드로 응답하여 더 나은 코드를 만들 수 있도록 검토자가 도움을 줄 수 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Macro-level knowledge sharing.&lt;/strong&gt; 여러분이 다른 사람의 코드를 검토하면서, 후에 당신에게 도움이 될 수 있는 새로운 기술을 배울 수 있습니다. 반대로 누군가가 당신의 코드를 검토하면서, 더 나은 방법을 제안할 수도 있습니다. 배운 것을 나중에 사용할 수 있다면 엔지니어로서 성장할 것입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Micro-level knowledge sharing.&lt;/strong&gt; 또는 특정 코드에 익숙한 사람의 수를 늘려 &lt;a href=&#34;https://en.wikipedia.org/wiki/Bus_factor&#34;&gt;Bus factor&lt;/a&gt; , &lt;a href=&#34;https://librewiki.net/wiki/%EB%B2%84%EC%8A%A4_%ED%8C%A9%ED%84%B0&#34;&gt;버스 팩터&lt;/a&gt; 요인을 완화하세요.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Direction sharing.&lt;/strong&gt; 이와 관련하여, 코드 리뷰는 당신이 진행 중인 작업에 대해 동료와 소통할 기회를 제공하여, 며칠 혹은 몇 주 동안 잘못된 방향으로 가는 일이 없도록 도울 수 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Communication practice.&lt;/strong&gt; 팀 내에서나 외부에서나 명확하게 의사소통할 수 있다는 것은 직장에서 성공하기 위한 가장 중요한 기술 중 하나입니다. 코드 리뷰를 통해 변경 목적을 설명하거나 변경에 대한 의견을 제시함으로써 명료한 글쓰기 연습을 할 수 있습니다. 운이 좋다면, 다음에 “정말 중요한” 것을 써야 할 때를 위한 준비가 될 수 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Historical record.&lt;/strong&gt; 제 경험으로는, 사람들은 누군가 자신의 커밋 메시지를 본다는 것을 알면 훨씬 더 잘 쓰는 경향이 있습니다. 이는 나중에 오래된 변경 사항을 되돌아볼 때 유용합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Something to discuss.&lt;/strong&gt; 변경 사항에 대한 합의를 할 때, 예를 들어 특정 알고리즘의 구체적인 세부 사항을 구두로 설명하고 동의하는 것은 어려울 수 있습니다. 코드만 가지고는 명확하지 않을 수 있으므로 코드와 함께 의사소통하는 것이 더 정확할 수 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Team cohesion.&lt;/strong&gt; 정기적으로 코드 리뷰를 수행하면, 각자 자기 일만 한다는 느낌이 아니라 팀이 다 같이 함께 일하는 것처럼 느껴집니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Reading practice.&lt;/strong&gt; 다른 사람의 코드를 읽는 연습을 통해 자신의 코드를 좀 더 가독성 있는(그러므로 유지 보수가 용이한) 코드로 만드는 방법을 기억하는 데 도움이 됩니다. 그러면 더 좋은 코드가 오래도록 이어집니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;저는 이 중에서 가장 가치 있는 것을 선택하라고 한다면 2,5,6번을 선택할 것입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[번역] just-in-time 실시간(JIT) 컴파일러에 대한 단기 과정</title>
      <link>https://lovejaco.github.io/posts/a-crash-course-in-just-in-time-compilers/</link>
      <pubDate>Tue, 15 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://lovejaco.github.io/posts/a-crash-course-in-just-in-time-compilers/</guid>
      <description>&lt;p&gt;원문: &lt;a href=&#34;https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/&#34;&gt;A crash course in just-in-time (JIT) compilers - Mozilla Hacks - the Web developer blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 글은 WebAssembly and what makes it fast 시리즈의 두 번째 파트입니다. 아직 다른 파트를 읽지 않았다면, &lt;a href=&#34;https://hacks.mozilla.org/2017/02/a-cartoon-intro-to-webassembly/&#34;&gt;처음부터 시작&lt;/a&gt; (또는 역자 &lt;a href=&#34;https://lovejaco.github.io/posts/a-cartoon-intro-to-webassembly/&#34;&gt;번역을 확인&lt;/a&gt;) 하는 것을 추천합니다.&lt;/p&gt;
&lt;p&gt;자바스크립트가 처음 나왔을 때는 느렸지만, JIT라는 것 때문에 빨라졌습니다. JIT는 어떻게 동작할까요?&lt;/p&gt;
&lt;h3 id=&#34;how-javascript-is-run-in-the-browser&#34;&gt;How JavaScript is run in the browser&lt;/h3&gt;
&lt;p&gt;개발자가 페이지에 자바스크립트를 추가하면 다음의 목표와 문제가 발생합니다.&lt;/p&gt;
&lt;p&gt;목표 : 컴퓨터에게 무엇을 해야 하는지 알려주고 싶습니다.&lt;br&gt;
문제 : 당신과 컴퓨터가 이해하는 언어가 서로 다릅니다.&lt;/p&gt;
&lt;p&gt;여러분은 인간의 언어로 말하고 컴퓨터는 기계어를 사용합니다. 여러분이 비록 자바스크립트나 다른 고급 프로그래밍 언어들을 인간의 언어라고 생각하지 않는다 하여도 실제로 (프로그래밍 언어)는 기계를 위한 것이 아니라 인간의 인식을 위해 설계되었습니다.&lt;/p&gt;
&lt;p&gt;그래서 자바스크립트 엔진의 역할은 인간의 언어를 기계가 이해하는 것으로 바꾸는 것입니다.&lt;/p&gt;
&lt;p&gt;저는 영화 &amp;ldquo;&lt;a href=&#34;https://en.wikipedia.org/wiki/Arrival_(film)&#34;&gt;컨택트(Arrival)&lt;/a&gt;&amp;ldquo;에서 인간과 외계인이 서로 대화하려고 하는 장면과 비슷하다고 생각합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://hacks.mozilla.org/files/2017/02/02-01-alien03-768x440.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;이 영화에서 인간과 외계인은 서로의 언어 간(단어-와-단어) 번역을 사용하지 않습니다.
두 집단은 세상에 대해 서로 다른 사고방식을 가지고 있고, 이는 인간과 기계에 대해서도 마찬가지입니다.(여기에 대해서는 다음 게시물에서 자세히 설명하겠습니다.)&lt;/p&gt;
&lt;p&gt;그렇다면 번역은 어떻게 이루어질까요?&lt;/p&gt;
&lt;p&gt;프로그래밍에서는 일반적으로 인터프리터 또는 컴파일러를 사용하는 두 가지 방법으로 기계어로 번열할 수 있습니다.&lt;/p&gt;
&lt;p&gt;인터프리터를 이용하는 번역의 경우에는, 대게 한 줄-한 줄(line-by-line)로 진행이 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://hacks.mozilla.org/files/2017/02/02-02-interp02-768x447.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;반면에 컴파일러는 실행하기에 앞서 미리 번역을 작성해 둡니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://hacks.mozilla.org/files/2017/02/02-03-compile02-768x456.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;번역을 처리하는 이러한 각각의 방법에는 장단점이 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;interpreter-pros-and-cons&#34;&gt;Interpreter pros and cons&lt;/h3&gt;
&lt;p&gt;인터프리터는 빠르게 준비하고 실행합니다. 코드를 실행하기 전에 전체 소스를 컴파일 할 필요가 없습니다. 단지 첫 번째 줄을 읽고 번역하고 실행합니다.&lt;/p&gt;
&lt;p&gt;웹 개발자가 작성한 코드를 빨리 실행해야 하는 것은 중요하며, 바로 이점 때문에 인터프리터는 자바스크립트와 같은 언어와 잘 맞는 것 같습니다.&lt;/p&gt;
&lt;p&gt;이점이 바로 초기에 브라우저가 자바스크립트 인터프리터를 사용한 이유입니다.&lt;/p&gt;
&lt;p&gt;그러나 인터프리터 사용의 단점은 동일한 코드를 두 번 이상 실행할 때 발생합니다. 예를 들어, 루프 안에서 똑같은 번역을 몇 번이고 반복해야 합니다.&lt;/p&gt;
&lt;h3 id=&#34;compiler-pros-and-cons&#34;&gt;Compiler pros and cons&lt;/h3&gt;
&lt;p&gt;컴파일러는 인터프리터와는 반대되는 절충점을 가지고 있습니다.&lt;/p&gt;
&lt;p&gt;실행 전에 컴파일 단계를 거쳐야 하기 때문에 시작하는데 조금 더 시간이 걸리지만, 루프를 통과할 때마다 번역을 반복할 필요가 없기 때문에 코드가 더 빨리 실행됩니다.&lt;/p&gt;
&lt;p&gt;또 다른 차이점은 컴파일러가 인터프리터 보다 코드를 살피고 편집할 수 있는 시간이 더 많기 때문에 코드를 더 빨리 실행하는데 유리합니다. 이 편집 과정을 최적화라고 부릅니다.&lt;/p&gt;
&lt;p&gt;인터프리터는 런타임에 변환 작업을 수행해야 하기 때문에 이러한 최적화를 파악하는데 많은 시간을 할애하기 어렵습니다.&lt;/p&gt;
&lt;h3 id=&#34;just-in-time-compilers-the-best-of-both-worlds&#34;&gt;Just-in-time compilers: the best of both worlds&lt;/h3&gt;
&lt;p&gt;인터프리터에서 루프 코드가 통과할 때마다 계속해서 다시 번역해야 하는 비 효율성을 제거하기 위해 브라우저는 컴파일러를 혼합하기 시작했습니다.&lt;/p&gt;
&lt;p&gt;브라우저마다 약간 다른 방식으로 동작하지만, 기본적인 아이디어는 동일합니다. 엔진에 모니터(프로파일러라고 불리는)를 추가하여, 실행 중인 코드를 감시하고 실행 횟수 및 사용된 타입(유형)을 기록합니다.&lt;/p&gt;
&lt;p&gt;처음 실행될 때에는 모든 코드가 인터프리터에서 실행됩니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://hacks.mozilla.org/files/2017/02/02-04-jit02-768x561.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;동일한 코드 라인이 몇 번 반복되면 해당 코드 세그먼트를 warm이라고 부릅니다. 그리고 더 많이 실행되면, 그것을 hot이라고 부릅니다.&lt;/p&gt;
&lt;h3 id=&#34;baseline-compiler&#34;&gt;Baseline compiler&lt;/h3&gt;
&lt;p&gt;함수가 달궈지기 시작하면 JIT가 컴파일을 시작합니다. 그런 다음 해당 컴파일을 저장합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://hacks.mozilla.org/files/2017/02/02-05-jit06-768x565.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;함수의 각 행은 &amp;ldquo;스텁&amp;quot;으로 컴파일됩니다. 스텁은 행 번호와 변수 유형별로 색인화됩니다 (이점이 중요한 이유에 대해서는 나중에 설명하겠습니다). 모니터가 코드의 실행을 주시하다가 동일한 코드가 동일한 변수 타입으로 반복 실행되는 것을 확인하면 컴파일 된 버전을 꺼냅니다.&lt;/p&gt;
&lt;p&gt;이 방법이 속도를 향상시키는 데 도움을 주긴 하지만 이미 말했듯이, 컴파일러가 할 수 있는 것이 더 있습니다. 시간이 좀 더 걸릴 수는 있겠지만 가장 효율적인 방법을 찾는 것&amp;hellip; 바로 최적화를 수행하는 일입니다.&lt;/p&gt;
&lt;p&gt;Baseline 컴파일러는 이러한 최적화 중 일부 만 수행합니다 (아래 예제를 예로 들겠습니다). 코드의 실행 시간이 너무 길어지는 것을 원치 않기 때문에 최적화 작업에 많은 시간을 들일 필요가 없습니다.&lt;/p&gt;
&lt;p&gt;그러나 코드가 정말 뜨겁다면 (동일 코드가 빈번하게 실행되고 있다면 - 역자 주) 최적화를 위해 추가적인 시간을 들일 가치가 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;optimizing-compiler&#34;&gt;Optimizing compiler&lt;/h3&gt;
&lt;p&gt;코드의 일부가 매우 뜨거워지면 모니터는 이를 최적화 컴파일러에 전송합니다. 이렇게 하면 함수의 또 다른, 그리고 더 빠른 버전이 생성되고 저장됩니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://hacks.mozilla.org/files/2017/02/02-06-jit09-768x560.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;코드의 더 빠른 버전을 만들기 위해, 최적화 컴파일러는 몇 가지 가정을 해야 합니다.&lt;/p&gt;
&lt;p&gt;예를 들어, 특정 생성자에 의해 생성된 모든 객체가 동일한 속성을 가지고 있고, 동일한 순서로 추가된 경우에는 이를 근거로 실행 절차를 좀 더 생략할 수 있습니다.&lt;/p&gt;
&lt;p&gt;최적화 컴파일러는 모니터가 수집한 정보를 사용하여 코드 실행을 관찰하고 판단합니다. 만약 반복문 코드의 결과가 직전까지 참(true)이었다면, 계속해서 참(true)일 것이라고 추측합니다.&lt;/p&gt;
&lt;p&gt;물론 자바스크립트에는 절대적인 보장이 없습니다. 99개의 객체가 모두 같은 모양을 가지고 있다가도 100번째 객체에서 그 속성을 잃어버릴 수 있습니다.&lt;/p&gt;
&lt;p&gt;따라서 컴파일된 코드를 실행하기 전에 그 가정이 유효한지 확인할 필요가 있습니다. 만약 유효하지 않다면, JIT는 추측이 틀렸다고 가정하고 최적화된 코드를 폐기합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://hacks.mozilla.org/files/2017/02/02-07-jit11-768x555.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;그러면, 인터프리터(코드를 최초에 실행할 때처럼) 또는 baseline 컴파일 버전에서 실행됩니다. 이 과정을 (최적화 해제) deoptimization (또는 bailing out) 이라고 부릅니다.&lt;/p&gt;
&lt;p&gt;일반적으로 최적화 컴파일러가 만들어낸 코드는 빠르게 실행되지만 때로는 예상치 못한 성능 문제를 일으킬 수 있습니다. 최적화되었다가 해제(deoptimized) 된 코드가 있다면 baseline 컴파일 버전을 실행하는 것보다도 느리게 실행될 수 있습니다.&lt;/p&gt;
&lt;p&gt;대부분의 브라우저에는 이러한 최적화/최적화 해제(deoptimized) 주기에서 벗어날 수 있는 제한이 추가되어 있습니다. 만약 JIT가 최적화 시도를 10회 이상 시도하였고, 그것을 폐기해야 한다면, 최적화 시도를 멈추게 됩니다.&lt;/p&gt;
&lt;h3 id=&#34;an-example-optimization-type-specialization&#34;&gt;An example optimization: Type specialization&lt;/h3&gt;
&lt;p&gt;많은 종류의 최적화 방법이 있지만 그중 한가지 유형을 살펴보면 최적화를 수행하는 방식에 대한 느낌을 얻을 수 있습니다. 컴파일러를 최적화하는 방법 중 가장 많이 알려진 방식은 타입 특수화(type specialization)에서 유래된 방식입니다.&lt;/p&gt;
&lt;p&gt;자바스크립트와 같은 동적 타입 시스템의 런타임은 약간의 추가 작업을 필요로 합니다.
예를 들어, 다음의 코드를 살펴보세요.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;arraySum&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt;) {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sum&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;sum&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;];
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;루프 안에서 += 스텝은 하나의 연산만 수행하는 것처럼 단순해 보이지만 동적 타이핑 때문에 예상보다 많은 단계를 필요로 합니다.&lt;/p&gt;
&lt;p&gt;arr 변수가 100 개의 정수로 이루어진 배열이라고 가정합시다. 일단 코드가 워밍업 되면 baseline 컴파일러는 함수의 각 오퍼레이션에 ​​대한 스텁을 생성합니다. 따라서 정수의 가산 연산(+=)을 처리하는 sum += arr [i]에 대한 스텁이 만들어집니다.&lt;/p&gt;
&lt;p&gt;그러나 sum과 arr[i]를 정수로 보장하기 어렵습니다. 자바스크립트의 타입은 동적이기 때문에 이후의 루프에서 arr[i] 값이 문자열이 될 가능성이 있습니다. 정수의 더하기 연산과 문자열 연결(concatenation)은 다른 오퍼레이션이기 때문에 둘은, 다른 기계 코드로 컴파일 됩니다.&lt;/p&gt;
&lt;p&gt;JIT가 이것을 처리하는 방법은 여러 개의 baseline 스텁을 컴파일하는 것입니다. 코드 조각이 단일 형태(monomorphic)인 경우 (즉, 항상 같은 타입으로 호출되는 경우) 하나의 스텁만 만들어집니다. 만약 다형성(하나의 경로에서 또 다른 코드를 다양한 타입으로 호출하는)인 경우, 해당 연산을 통해 나온 각각의 타입 조합들의 스텁이 만들어집니다.&lt;/p&gt;
&lt;p&gt;이는 JIT가 스텁을 선택하기 전에 많은 질문을 던저야 한다는 것을 의미합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://hacks.mozilla.org/files/2017/02/02-08-decision_tree01-768x394.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;각 코드 라인은 baseline 컴파일러에 자체 스텁 집합이 있기 때문에 JIT는 코드 라인이 실행될 때마다 타입을 계속 확인해야 합니다. 그래서 루프를 반복할 때마다, 동일한 질문을 해야만 합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://hacks.mozilla.org/files/2017/02/02-09-jit_loop02-768x496.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;만약 JIT가 이러한 검사를 반복할 필요가 없다면 코드는 훨씬 더 빨리 실행될 수 있습니다. 이것이 최적화 컴파일러가 하는 일 중 하나입니다.&lt;/p&gt;
&lt;p&gt;최적화 컴파일러에서는 전체 함수가 모두 컴파일 됩니다. 타입 검사는 루프 전에 발생하도록 이동합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://hacks.mozilla.org/files/2017/02/02-10-jit_loop02-768x488.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;일부 JIT는 이를 좀 더 최적화합니다. 예를 들어, Firefox에는 정수만 포함하는 배열에 대한 특별한 명세가 있습니다. arr 변수가 이러한 배열 중 하나인 경우 JIT는 arr[i]가 정수인지 확인할 필요가 없습니다. 즉, 루프로 진입하기 전에 JIT는 전체 타입 검사를 수행할 수 있음을 의미합니다.&lt;/p&gt;
&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;코드를 실행할 때 코드를 모니터링하고 최적화하기 위해 핫 코드의 경로를 전송하여 최적화함으로써 자바스크립트를 보다 빠르게 실행합니다. 이런 결과로 대부분의 자바스크립트 응용 프로그램에서 성능이 몇 배 향상되었습니다.&lt;/p&gt;
&lt;p&gt;그러나 이러한 개선에도 불구하고 자바스크립트의 성능은 여전히 예측할 수 없습니다. 그래서 JIT는 보다 빠른 성능을 위해 런타임에 약간의 오버헤드를 추가하였습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;최적화(optimization) 최적화 해제(deoptimization)&lt;/li&gt;
&lt;li&gt;bailouts 발생 시 모니터 기록(bookkeeping)과 복구 정보에 이용되는 메모리&lt;/li&gt;
&lt;li&gt;baseline 컴파일러와 최적화 컴파일러에 저장된 함수 버전을 사용하는데 쓰이는 메모리&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;아직 개선할 여지가 남아 있습니다. 오버헤드를 제거하여 성능을 예측 가능하도록 만들 수 있습니다. 이것이 웹어셈블리가 하는 것 중 하나입니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://hacks.mozilla.org/2017/02/a-crash-course-in-assembly/&#34;&gt;다음 게시물&lt;/a&gt;에서는 어셈블리와 컴파일러가 어떻게 작동하는지에 대해 자세히 설명할 것입니다.&lt;/p&gt;
&lt;h3 id=&#34;about-lin-clarkhttpstwittercomlinclark&#34;&gt;About &lt;a href=&#34;https://twitter.com/linclark&#34;&gt;Lin Clark&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Lin works in Advanced Development at Mozilla, with a focus on Rust and WebAssembly.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/linclark&#34;&gt;https://twitter.com/linclark&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://twitter.com/linclark&#34;&gt;@linclark&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://hacks.mozilla.org/author/lclarkmozilla-com/&#34;&gt;More articles by Lin Clark…&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[번역] 만화로 소개하는 웹어셈블리</title>
      <link>https://lovejaco.github.io/posts/a-cartoon-intro-to-webassembly/</link>
      <pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://lovejaco.github.io/posts/a-cartoon-intro-to-webassembly/</guid>
      <description>&lt;p&gt;원문: &lt;a href=&#34;https://hacks.mozilla.org/2017/02/a-cartoon-intro-to-webassembly/&#34;&gt;cartoon intro to WebAssembly&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;번역기와 함께 주관적인 이해를 바탕으로 작성되어, 오역 가능성이 높습니다. 모든 저작권은 원작자에게 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;자바스크립트는 1995년에 만들어졌습니다. 처음 10년 동안은 빠르게 동작하도록 설계되지 않았고, 빠르지도 않았습니다.&lt;/p&gt;
&lt;p&gt;그 이후에 브라우저의 경쟁이 치열해지기 시작했습니다.&lt;/p&gt;
&lt;p&gt;2008년에 브라우저의 성능 전쟁이 시작되면서, 다수의 브라우저에서 JITs라고도 불리는 JIT(실시간 just-in-time) 컴파일러를 도입했습니다. JIT는 자바스크립트가 실행되는 패턴을 관찰하고 그것을 기반으로 코드를 더 빠르게 실행할 수 있었습니다.&lt;/p&gt;
&lt;p&gt;이러한 JIT의 도입은 자바스크립트 성능의 변곡점을 가져왔습니다. 자바스크립트의 실행이 10배 빨라졌습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://hacks.mozilla.org/files/2017/02/01-01-perf_graph05-768x628.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;이렇게 성능이 향상되면서, 자바스크립트는 Node.js로 서버 측 프로그래밍을 작성하는 것처럼 아무도 예상하지 못했던 곳에서 사용되기 시작했습니다. 성능 향상은 자바스크립트를 완전히 새로운 종류의 문제에서 사용하는 것을 가능하게 했습니다.&lt;/p&gt;
&lt;p&gt;우리는 지금 웹어셈블리와 함께 그 변곡점 중 어느 다른 한 곳에 있는지도 모릅니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://hacks.mozilla.org/files/2017/02/01-02-perf_graph10-768x633.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;그럼, 이제 무엇이 웹어셈블리를 빠르게 만드는지 알아보려고 합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Background:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/&#34;&gt;A crash course in just-in-time (JIT) compilers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hacks.mozilla.org/2017/02/a-crash-course-in-assembly/&#34;&gt;A crash course in assembly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;WebAssembly, the present:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://hacks.mozilla.org/2017/02/creating-and-working-with-webassembly-modules/&#34;&gt;Creating and working with WebAssembly modules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hacks.mozilla.org/2017/02/what-makes-webassembly-fast/&#34;&gt;What makes WebAssembly fast?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;WebAssembly, the future:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://hacks.mozilla.org/?p=30522&#34;&gt;Where is WebAssembly now and what’s next&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;about-lin-clarkhttpstwittercomlinclark&#34;&gt;About &lt;a href=&#34;https://twitter.com/linclark&#34;&gt;Lin Clark&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Lin works in Advanced Development at Mozilla, with a focus on Rust and WebAssembly.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/linclark&#34;&gt;https://twitter.com/linclark&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://twitter.com/linclark&#34;&gt;@linclark&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://hacks.mozilla.org/author/lclarkmozilla-com/&#34;&gt;More articles by Lin Clark…&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>